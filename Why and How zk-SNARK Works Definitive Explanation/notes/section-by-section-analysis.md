# 🧩 Section-by-Section Analysis: Why and How zk-SNARK Works

이 문서는 zk-SNARK의 핵심 수학적 구조를 "왜 필요한가(Why) → 어떻게 가능한가(How) → 어떤 방식으로 구성되는가(What)"라는 흐름으로 설명한 기술 논문이다.  
각 섹션을 분석하여 개념 정의, 문제 설정, 해법 프레임워크, 증명 흐름을 정리하였다.

---

## **Section 1. Introduction**

- Zero-Knowledge Proof (ZKP)의 현실적 필요성과 응용 예시 소개
- zk-SNARKs의 정의: _Succinct Non-interactive Argument of Knowledge_ with Zero-Knowledge
- 용례:
  - 비밀번호 없는 인증
  - 프라이버시 보호 결제
  - 블록체인 연산 위임 및 오프체인 검증
- 목표: zk-SNARK이 실제로 어떻게 작동하는지를 직관적으로 설명

---

## **Section 2. The Medium of a Proof**

- 기본적인 증명 방식의 효율성과 보안성 문제 제시
- 다항식의 동일성 검증을 위한 핵심 성질 제시: 두 다항식이 d차이면, d+1개의 점에서 일치하지 않으면 다름
- 이 성질을 활용하여 "지식을 증명하지만 노출하지 않는" 프레임워크 구상

---

## **Section 3. Polynomial-based zk-Proofs**

### **3.1 Proving Knowledge of a Polynomial**

#### 🔍 핵심 문제

- 목표: 증명자가 특정 다항식 `p(x)`를 알고 있음을 증명
- 검증자는 보조 다항식 `t(x)`를 만들고, `p(x) = t(x) · h(x)` 구조를 검증하고자 함
- 방법: 무작위 점 `r`을 정해 `p(r) = t(r) · h(r)`가 성립하는지 비교

#### ⚠️ 한계

- 증명자가 r을 안다면, 해당 r에 맞는 가짜 `p(r)`와 `h(r)`를 위조 가능
- `p(x)`의 차수를 높여도 단일 점에서만 맞으면 속일 수 있음

### **3.2 What Can Go Wrong?**

- `p(x)`의 차수가 `t(x)`보다 크거나 무관한 경우에도, 특정 r에만 맞게 값을 조작 가능
- 따라서 이 단일점 검증은 **검증자 입장에서 의미 있는 제약이 아님**
- → 더 강한 구조가 필요해짐 (즉, 암호화된 상태에서도 신뢰 가능한 계산 구조)

### **3.3 Obscure Evaluation and Homomorphic Encryption**

#### 🔍 핵심 문제

- 증명자가 `r`이나 `s`를 받게 되면 즉석으로 거짓 값을 조작할 위험 존재

#### ✅ 해결 아이디어: Homomorphic Encryption

- 검증자는 `s`에 대한 지수승 값만 암호화해서 제공:
  - `E(s^i) = g^{s^i}`
- 증명자는 계수 `c_i`만 알고 있고, 아래와 같은 방식으로 계산 가능:
  - 덧셈: `E(a) * E(b) = E(a + b)`
  - 스칼라곱: `E(a)^k = E(k · a)`

#### 💡 예시:

- `p(x) = 2x^2 + 3x + 5`
- 증명자가 받은 것:
  - `E(s^2) = g^{s^2}`
  - `E(s) = g^s`
  - `E(1) = g`
- 계산:
  \[
  E(p(s)) = E(s^2)^2 · E(s)^3 · g^5 = g^{2s^2 + 3s + 5}
  \]

#### 💬 자주 등장한 질문들

| 질문                                    | 해설                                                                     |
| --------------------------------------- | ------------------------------------------------------------------------ |
| 증명자는 s를 모르는데 어떻게 계산 가능? | s의 지수승만 암호화되어 제공되며, 증명자는 계수만 곱해서 `g^{p(s)}` 계산 |
| g는 숨겨야 할 값 아닌가?                | ❌ 아니다. g는 공개된 generator이며, 숨기는 대상은 지수(m)               |
| g^{p(s)}를 보면 p(s)를 알 수 있지 않나? | 아니요. DLP (Discrete Logarithm Problem) 때문에 p(s) 추정은 불가능함     |

### **3.4 Restricting a Polynomial**

#### 🔍 핵심 문제

- 증명자가 `E(s^i)` 외의 임의의 값을 사용해 `g^{p(s)}`를 조작할 수 있음

#### ✅ 해결 아이디어: KEA 기반 검증

- 검증자는 `g^{s^i}`뿐 아니라, `g^{α·s^i}`도 제공
- 증명자는 아래 값들을 계산:
  - `gp = g^{p(s)}`
  - `gp' = g^{α·p(s)}`
- 검증자는 다음 등식이 성립하는지 확인:
  \[
  (gp)^α = gp'
  \]
- 이를 통해 증명자가 **검증자가 제공한 s^i들만 사용했음을 증명**

#### 💬 관련 질문 정리

| 질문                                 | 해설                                                                             |
| ------------------------------------ | -------------------------------------------------------------------------------- |
| α는 누가 알고 있는가?                | 검증자만 알고 있음                                                               |
| 증명자는 g^{α·p(s)}도 계산 가능한가? | 네, 제공된 `g^{α·s^i}`에 동일한 계수를 곱해서 계산 가능                          |
| 왜 이 구조가 안전한가?               | 증명자는 α를 몰라 위조할 수 없고, 검증자는 관계만 검증하므로 Zero-Knowledge 유지 |

---

### **3.5: Zero-Knowledge via Masking**

#### 🔍 핵심 문제

- 지금까지의 구조에서는 `g^{p(s)}`, `g^{h(s)}` 등이 증명 과정에서 그대로 노출됨
- 이 값들이 공격자에게 수학적으로 의미 있는 정보를 누설할 가능성 존재
  - 예: 지수 자체를 추정할 수 없더라도 통계적 정보 노출 가능성

#### ✅ 해결 아이디어: 마스킹 (Masking with Random Delta)

- 증명자가 무작위 값 δ를 곱해서 모든 값을 숨김:
  - `g^{p(s)} → g^{δ·p(s)}`
  - `g^{h(s)} → g^{δ·h(s)}`
  - `g^{α·p(s)} → g^{α·δ·p(s)}`
- 이로 인해 값은 은닉되지만, 다음과 같은 **관계는 유지됨**:
  \[
  (g^{δ·h(s)})^{t(s)} = g^{δ·p(s)}
  \quad,\quad
  (g^{δ·p(s)})^α = g^{α·δ·p(s)} = (g^{δ·h(s)})^{α·t(s)}
  \]
- 검증자는 이 구조적 등식만 확인하면 됨

> > 증명 내용은 전혀 노출되지 않으면서도, 수학적으로 제약 조건이 만족되었음을 증명
> > Zero-Knowledge 성질이 성립하는 마지막 핵심 단계

---

### **3.6: From Interactive to Non-Interactive Proof**

#### 🔍 핵심 문제

- 지금까지의 검증 구조는 여전히 "대화형"
  - 검증자가 `s`, `α` 등을 증명자에게 전달해야 함
  - 실전 시스템에서는 상호작용이 불가능하거나 비효율적

#### ✅ 해결 아이디어: CRS (Common Reference String)

- `s`, `α`, `g^{s^i}`, `g^{α·s^i}` 등을 **Trusted Setup**을 통해 미리 생성
- 이들을 "공통 참조 문자열(CRS)"로 고정하여 모든 증명자가 참조 가능하게 함
- 증명자는 CRS만 알고 있어도 `(g^{δ·p(s)})`, `(g^{α·δ·p(s)})` 등을 생성 가능

---

### **3.6.1: Multiplication of Encrypted Values**

#### ⚠️ 문제

- 암호화된 값의 덧셈은 가능:

  $$
  g^a \cdot g^b = g^{a+b}
  $$

- 하지만 암호화된 값의 **곱셈**은 불가능:

  $$
  g^{a} \cdot g^{b} \neq g^{a \cdot b}
  $$

#### ✅ 해결 아이디어 : 곱셈 제약을 다항식 전체에 포함시킴

- 곱셈 제약 예: `a · b = c`
- 이를 회로 전체의 제약 시스템으로 변환:

  $$
  p(x) = L(x) \cdot R(x) - O(x)
  $$

- 조건: $t(x) \mid p(x)$ (즉, p(x)는 t(x)로 나누어 떨어져야 함)
- 검증은 다음과 같이 암호화 상태로 수행:

  $$
  g^{p(s)} = g^{t(s) \cdot h(s)}
  \Rightarrow
  g^{p(s)} = (g^{h(s)})^{t(s)}
  $$

#### 🧩 핵심 개념: QAP (Quadratic Arithmetic Program)

- 회로의 각 제약은 x의 특정 위치에 매핑됨
- 제약 만족 여부를 $x = r_i$ 점에서 평가 가능하게 구성
- 전체 p(x)는 제약 위치들에서 0이 되도록 설계됨

---

#### **3.6.2: Trusted Party Setup**

##### 🔐 문제

> > CRS를 어떻게 신뢰할 수 있는가?

- zk-SNARK은 CRS(Common Reference String)에 `g^s`, `g^{s^2}`, ... 등 사전 계산된 값을 포함
- 이때 s를 알면 위조 증명이 가능 (trapdoor 존재)

##### ✅ 해결 아이디어 : 다자간 CRS 생성(Setup Ceremony)

- 여러 명이 각자 자신의 sᵢ를 사용해 CRS 일부를 생성
- 최종 CRS는 모두의 sᵢ가 조합된 구조로 구성됨
- **Powers of Tau**: `g^τ`, `g^{τ^2}`, ..., `g^{α·τ^i}` 등을 모두 사전 생성
- 신뢰 가정: **“단 한 명만 정직하면 전체 CRS는 안전”** (Trusting One out of Many)
- 각 참여자가 자신의 sᵢ를 폐기하면, 전체 CRS의 trapdoor는 소멸됨
- 위조자는 전체 trapdoor를 복원해야 하지만, 모든 참여자의 sᵢ를 알 수 없음
  > > Section 3.6은 zk-SNARK을 현실적으로 사용 가능하게 만드는 마지막 구성 단계

---

#### **3.6.3: Trusting One out of Many**

##### 📌 주요 메시지

- CRS 생성의 가장 안전한 방법은 **여러 독립된 참여자**가 함께 참여하는 것
- 개별 참여자는 자신의 랜덤 값을 사용해 일부분을 계산하고, 이후 이를 폐기
- 이 구조는 "Ceremony"로 불리며 실제 프로젝트들에서 사용됨 (e.g., Zcash, Plonk)

##### 🧩 CRS 보안 구조

| 구조 요소       | 설명                                                   |
| --------------- | ------------------------------------------------------ |
| 참여자 수       | 많을수록 안전성 ↑                                      |
| 폐기된 trapdoor | 하나라도 있으면 위조 불가                              |
| 공개된 값       | `g^s`, `g^{s^2}`, ...는 공개되나 trapdoor는 알 수 없음 |

---

### ✅ 결론 요약

- zk-SNARK은 다항식 지식 증명 구조 + 암호화된 계산 + 정당성 증명 + 은닉성을 단계적으로 결합
- 증명자는 s, p(x), h(x)를 이용해 `g^{p(s)}`, `g^{h(s)}` 등을 계산
- 검증자는 관계식만으로 정당성 검증 (값은 모름)
- 다음 섹션부터 Zero-Knowledge 보장 및 비대화형 구조 본격화
