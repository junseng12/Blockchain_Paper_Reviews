# 🧩 Section-by-Section Analysis: Why and How zk-SNARK Works

이 문서는 zk-SNARK의 핵심 수학적 구조를 "왜 필요한가(Why) → 어떻게 가능한가(How) → 어떤 방식으로 구성되는가(What)"라는 흐름으로 설명한 기술 논문이다.  
각 섹션을 분석하여 개념 정의, 문제 설정, 해법 프레임워크, 증명 흐름을 정리하였다.

---

## **Section 1. Introduction**

- Zero-Knowledge Proof (ZKP)의 현실적 필요성과 응용 예시 소개
- zk-SNARKs의 정의: _Succinct Non-interactive Argument of Knowledge_ with Zero-Knowledge
- 용례:
  - 비밀번호 없는 인증
  - 프라이버시 보호 결제
  - 블록체인 연산 위임 및 오프체인 검증
- 목표: zk-SNARK이 실제로 어떻게 작동하는지를 직관적으로 설명

---

## **Section 2. The Medium of a Proof**

- 기본적인 증명 방식의 효율성과 보안성 문제 제시
- 다항식의 동일성 검증을 위한 핵심 성질 제시: 두 다항식이 d차이면, d+1개의 점에서 일치하지 않으면 다름
- 이 성질을 활용하여 "지식을 증명하지만 노출하지 않는" 프레임워크 구상

---

## **Section 3. Polynomial-based zk-Proofs**

### **3.1 Proving Knowledge of a Polynomial**

#### 🔍 핵심 문제

- 목표: 증명자가 특정 다항식 `p(x)`를 알고 있음을 증명
- 검증자는 보조 다항식 `t(x)`를 만들고, `p(x) = t(x) · h(x)` 구조를 검증하고자 함
- 방법: 무작위 점 `r`을 정해 `p(r) = t(r) · h(r)`가 성립하는지 비교

#### ⚠️ 한계

- 증명자가 r을 안다면, 해당 r에 맞는 가짜 `p(r)`와 `h(r)`를 위조 가능
- `p(x)`의 차수를 높여도 단일 점에서만 맞으면 속일 수 있음

### **3.2 What Can Go Wrong?**

- `p(x)`의 차수가 `t(x)`보다 크거나 무관한 경우에도, 특정 r에만 맞게 값을 조작 가능
- 따라서 이 단일점 검증은 **검증자 입장에서 의미 있는 제약이 아님**
- → 더 강한 구조가 필요해짐 (즉, 암호화된 상태에서도 신뢰 가능한 계산 구조)

### **3.3 Obscure Evaluation and Homomorphic Encryption**

#### 🔍 핵심 문제

- 증명자가 `r`이나 `s`를 받게 되면 즉석으로 거짓 값을 조작할 위험 존재

#### ✅ 해결 아이디어: Homomorphic Encryption

- 검증자는 `s`에 대한 지수승 값만 암호화해서 제공:
  - `E(s^i) = g^{s^i}`
- 증명자는 계수 `c_i`만 알고 있고, 아래와 같은 방식으로 계산 가능:
  - 덧셈: `E(a) * E(b) = E(a + b)`
  - 스칼라곱: `E(a)^k = E(k · a)`

#### 💡 예시:

- `p(x) = 2x^2 + 3x + 5`
- 증명자가 받은 것:
  - `E(s^2) = g^{s^2}`
  - `E(s) = g^s`
  - `E(1) = g`
- 계산:
  \[
  E(p(s)) = E(s^2)^2 · E(s)^3 · g^5 = g^{2s^2 + 3s + 5}
  \]

#### 💬 자주 등장한 질문들

| 질문                                    | 해설                                                                     |
| --------------------------------------- | ------------------------------------------------------------------------ |
| 증명자는 s를 모르는데 어떻게 계산 가능? | s의 지수승만 암호화되어 제공되며, 증명자는 계수만 곱해서 `g^{p(s)}` 계산 |
| g는 숨겨야 할 값 아닌가?                | ❌ 아니다. g는 공개된 generator이며, 숨기는 대상은 지수(m)               |
| g^{p(s)}를 보면 p(s)를 알 수 있지 않나? | 아니요. DLP (Discrete Logarithm Problem) 때문에 p(s) 추정은 불가능함     |

### **3.4 Restricting a Polynomial**

#### 🔍 핵심 문제

- 증명자가 `E(s^i)` 외의 임의의 값을 사용해 `g^{p(s)}`를 조작할 수 있음

#### ✅ 해결 아이디어: KEA 기반 검증

- 검증자는 `g^{s^i}`뿐 아니라, `g^{α·s^i}`도 제공
- 증명자는 아래 값들을 계산:
  - `gp = g^{p(s)}`
  - `gp' = g^{α·p(s)}`
- 검증자는 다음 등식이 성립하는지 확인:
  \[
  (gp)^α = gp'
  \]
- 이를 통해 증명자가 **검증자가 제공한 s^i들만 사용했음을 증명**

#### 💬 관련 질문 정리

| 질문                                 | 해설                                                                             |
| ------------------------------------ | -------------------------------------------------------------------------------- |
| α는 누가 알고 있는가?                | 검증자만 알고 있음                                                               |
| 증명자는 g^{α·p(s)}도 계산 가능한가? | 네, 제공된 `g^{α·s^i}`에 동일한 계수를 곱해서 계산 가능                          |
| 왜 이 구조가 안전한가?               | 증명자는 α를 몰라 위조할 수 없고, 검증자는 관계만 검증하므로 Zero-Knowledge 유지 |

---

### **3.5: Zero-Knowledge via Masking**

#### 🔍 핵심 문제

- 지금까지의 구조에서는 `g^{p(s)}`, `g^{h(s)}` 등이 증명 과정에서 그대로 노출됨
- 이 값들이 공격자에게 수학적으로 의미 있는 정보를 누설할 가능성 존재
  - 예: 지수 자체를 추정할 수 없더라도 통계적 정보 노출 가능성

#### ✅ 해결 아이디어: 마스킹 (Masking with Random Delta)

- 증명자가 무작위 값 δ를 곱해서 모든 값을 숨김:
  - `g^{p(s)} → g^{δ·p(s)}`
  - `g^{h(s)} → g^{δ·h(s)}`
  - `g^{α·p(s)} → g^{α·δ·p(s)}`
- 이로 인해 값은 은닉되지만, 다음과 같은 **관계는 유지됨**:
  \[
  (g^{δ·h(s)})^{t(s)} = g^{δ·p(s)}
  \quad,\quad
  (g^{δ·p(s)})^α = g^{α·δ·p(s)} = (g^{δ·h(s)})^{α·t(s)}
  \]
- 검증자는 이 구조적 등식만 확인하면 됨

> > 증명 내용은 전혀 노출되지 않으면서도, 수학적으로 제약 조건이 만족되었음을 증명
> > Zero-Knowledge 성질이 성립하는 마지막 핵심 단계

---

### **3.6: From Interactive to Non-Interactive Proof**

#### 🔍 핵심 문제

- 지금까지의 검증 구조는 여전히 "대화형"
  - 검증자가 `s`, `α` 등을 증명자에게 전달해야 함
  - 실전 시스템에서는 상호작용이 불가능하거나 비효율적

#### ✅ 해결 아이디어: CRS (Common Reference String)

- `s`, `α`, `g^{s^i}`, `g^{α·s^i}` 등을 **Trusted Setup**을 통해 미리 생성
- 이들을 "공통 참조 문자열(CRS)"로 고정하여 모든 증명자가 참조 가능하게 함
- 증명자는 CRS만 알고 있어도 `(g^{δ·p(s)})`, `(g^{α·δ·p(s)})` 등을 생성 가능

---

### **3.6.1: Multiplication of Encrypted Values**

#### ⚠️ 문제

- 암호화된 값의 덧셈은 가능:

  $$
  g^a \cdot g^b = g^{a+b}
  $$

- 하지만 암호화된 값의 **곱셈**은 불가능:

  $$
  g^{a} \cdot g^{b} \neq g^{a \cdot b}
  $$

#### ✅ 해결 아이디어 : 곱셈 제약을 다항식 전체에 포함시킴

- 곱셈 제약 예: `a · b = c`
- 이를 회로 전체의 제약 시스템으로 변환:

  $$
  p(x) = L(x) \cdot R(x) - O(x)
  $$

- 조건: $t(x) \mid p(x)$ (즉, p(x)는 t(x)로 나누어 떨어져야 함)
- 검증은 다음과 같이 암호화 상태로 수행:

  $$
  g^{p(s)} = g^{t(s) \cdot h(s)}
  \Rightarrow
  g^{p(s)} = (g^{h(s)})^{t(s)}
  $$

#### 🧩 핵심 개념: QAP (Quadratic Arithmetic Program)

- 회로의 각 제약은 x의 특정 위치에 매핑됨
- 제약 만족 여부를 $x = r_i$ 점에서 평가 가능하게 구성
- 전체 p(x)는 제약 위치들에서 0이 되도록 설계됨

---

#### **3.6.2: Trusted Party Setup**

##### 🔐 문제

> > CRS를 어떻게 신뢰할 수 있는가?

- zk-SNARK은 CRS(Common Reference String)에 `g^s`, `g^{s^2}`, ... 등 사전 계산된 값을 포함
- 이때 s를 알면 위조 증명이 가능 (trapdoor 존재)

##### ✅ 해결 아이디어 : 다자간 CRS 생성(Setup Ceremony)

- 여러 명이 각자 자신의 sᵢ를 사용해 CRS 일부를 생성
- 최종 CRS는 모두의 sᵢ가 조합된 구조로 구성됨
- **Powers of Tau**: `g^τ`, `g^{τ^2}`, ..., `g^{α·τ^i}` 등을 모두 사전 생성
- 신뢰 가정: **“단 한 명만 정직하면 전체 CRS는 안전”** (Trusting One out of Many)
- 각 참여자가 자신의 sᵢ를 폐기하면, 전체 CRS의 trapdoor는 소멸됨
- 위조자는 전체 trapdoor를 복원해야 하지만, 모든 참여자의 sᵢ를 알 수 없음
  > > Section 3.6은 zk-SNARK을 현실적으로 사용 가능하게 만드는 마지막 구성 단계

---

#### **3.6.3: Trusting One out of Many**

##### 📌 주요 메시지

- CRS 생성의 가장 안전한 방법은 **여러 독립된 참여자**가 함께 참여하는 것
- 개별 참여자는 자신의 랜덤 값을 사용해 일부분을 계산하고, 이후 이를 폐기
- 이 구조는 "Ceremony"로 불리며 실제 프로젝트들에서 사용됨 (e.g., Zcash, Plonk)

##### 🧩 CRS 보안 구조

| 구조 요소       | 설명                                                   |
| --------------- | ------------------------------------------------------ |
| 참여자 수       | 많을수록 안전성 ↑                                      |
| 폐기된 trapdoor | 하나라도 있으면 위조 불가                              |
| 공개된 값       | `g^s`, `g^{s^2}`, ...는 공개되나 trapdoor는 알 수 없음 |

---

### **3.7: Succinct Non-Interactive Argument of Knowledge of Polynomial**

#### 🔐 문제

- 지금까지 발생한 문제들의 구현은 자체는 안정했지만, 여전히 필요한 그룹을 통한 ‘대화적’ 방식이었다.
- 사용자 간의 그룹에 의전없이 다음과 같은 관계를 검증할 수 있어야한다:

  1. $g^{p(s)} = g^{t(s)h(s)}$
  2. $g^{\alpha p(s)} = (g^{p(s)})^{\alpha}$

#### ✅ 해결 아이디어: 데이터를 가르기위한 전망적 검증

- 필요 검증값:

  - $\pi_1 = g^{\delta p(s)}$
  - $\pi_2 = g^{\delta h(s)}$
  - $\pi_3 = g^{\alpha\delta p(s)}$

- 검증자는 CRS에 기반해 여기서 검증 값을 생성
- 검사는 pairing을 이용하여 검증:

  - $e(\pi_1, g) = e(\pi_2, g^{t(s)})$
  - $e(\pi_3, g) = e(\pi_1, g^{\alpha})$

#### 🧠 해석

- 이 결과들은 pairing 가성을 활용한 ‘결과의 인수가 다양해진’ 것이기 때문에, 장소가 가능해지고 ‘non-interactive’ 구조를 가지는 다음 과 같은 시스템이 구성되는 것이다.

---

### **4.1: Computation**

#### 🔐 문제

- 실제 ZK-SNARK의 검증은 “계산과정”을 검증해야 한다
- 다크림이나 arithmetic circuit에서 다음과 같은 전차가 필요:

  - 값 드림
  - 인수 계산
  - 반복적 결과 계산

#### ✅ 해결 아이디어: 전체 획사가 되는 검증

- 전체 계산을 “구성규칙” “계산과정”으로 나누고,
- 모든 역할을 QAP의 $p(x) = l(x) \cdot r(x) - o(x)$ 형태로 복사
- $t(x) \mid p(x)$ 을 검증하면 전체 계산과정이 만적된 것을 검증

---

### **4.2: Single Operation**

#### 🔐 문제

- $l(x) \cdot r(x) = o(x)$ 형태의 공수 역할을 ZK-SNARK으로 검증하려면?
- $p(x) = l(x)r(x) - o(x)$ 을 구성하고 CRS로 $g^{l(s)}, g^{r(s)}, g^{o(s)}$ 을 가지는 유저가 검증값과 같이 저장#

#### ✅ 해결 아이디어: 모든 검증을 $p(x) \Rightarrow t(x)h(x)$ 형태로 추적

- 데이터 계산 검증을 시작
- 방식: $l(x)r(x) = o(x) + t(x)h(x)$

#### 🧠 해석

- $p(x) = l(x)r(x) - o(x) \Rightarrow t(x) \mid p(x)$ 으로 변환
- 이중 $p(x)$ 에 대해 pairing 검증 가능

---

### **4.3: Enforcing Operation**

#### 🔐 문제

- 검증자가 $p(x) = l(x)$, $p(x) = l(x) - r(x)$ 같은 것으로 적용해가면 검증가 “다른 명세”에 관한 검증걷4 되는 문제 발생
- pairing 가 $l(s) \cdot r(s)$ 을 조합하는 중요한 검증 다크림을 “다시 사용”할 수 없다#

#### ✅ 해결 아이디어: l(s), r(s), o(s)의 값을 모두 검증가 제시

- $l(x)r(x) = o(x) + t(x)h(x)$ 형태로 바꾼 것
- 검사는 $g^{l(s)}, g^{r(s)}, g^{o(s)}$ 을 모두 가지고, $g^{l(s)r(s)}$ 을 pairing을 통해 조합 검증

#### 🧠 해석

- 검증자가 pairing을 2회 이용하지 못하게 검증구조를 구성
- $l(s)r(s) = o(s) + t(s)h(s)$ 검증을 위해 CRS에 $g^{l(s)}, g^{r(s)}, g^{o(s)}$ 전달

---

### **4.4: Proof of Operation**

#### 🔐 문제

- 계산과정이 $l \cdot r = o$ 검증이면 ZK에서 “변수 인수 모두가 검증값”이 되어 Zero-Knowledge 가 사라진다

#### ✅ 해결 아이디어: o(x)를 원시로 보내고, $l, r$ 만 masking

- 검증자가 $g^{\delta l(s)}, g^{\delta r(s)}$ 만 가지고,
- $g^{o(s)}$ 는 그대로 검사에게 제시

#### 🧠 해석

- $o$ 값은 검증가 없어도 Zero-Knowledge 를 복구하기 위해 구성을 변경
- $g^{l(s)}, g^{r(s)}$ 만 masking과 pairing으로 검증

---

### **4.5: Multiple Operations**

#### 🔍 핵심 문제

- 지금까지는 단일 연산(`a × b = c`)만 다뤘지만, 현실 회로는 여러 개의 연산을 포함
- 예: `a × b = c`, `d × e = f`, `g × h = i` → 각각 다른 위치(x=1,2,3)에서 동작
- 이때 모든 연산이 "하나의 다항식 구조" 내에서 표현되어야 함

---

### **4.5.1: Polynomial Interpolation**

#### 📌 목적

- 각 연산을 특정 위치 x ∈ {1,2,3,...}로 매핑
- 그 위치에서 연산이 만족되도록 다항식을 구성

#### ✅ 핵심 기법: 보간 (Interpolation)

- 각 x=i에서 제약을 만족시키는 다항식 `p(x)`를 구성
- 이를 위해 **소거 다항식 (vanishing polynomial)** `t(x) = (x-1)(x-2)...(x-n)` 사용
- 조건: `p(x)`는 `t(x)`로 나누어떨어져야 하며 (즉, `t(x) | p(x)`), 이는 각 위치에서 제약이 성립함을 의미

---

### **4.5.2: Multi-Operation Polynomials**

#### ⚠️ 문제

- Prover는 다항식 `l(x), r(x), o(x)`를 제시해야 함
- 하지만 `l(x)`를 조작하여 각 위치에서 서로 다른 값을 나타내는 방식으로 위조 가능

  - 예: `l(x) = a1 at x=1, a2 at x=2, a3 at x=3`처럼 조작 가능

#### ✅ 해결 원리: 동일한 변수는 동일한 값 유지

- 하나의 회로 내에서 동일한 변수 `a`는 항상 동일한 값을 가져야 함
- Prover가 `l(x)`를 임의로 설정해 각 위치에서 다른 값이 나오게 하면 전체 회로 제약을 위반하게 됨
- 다항식의 **계수를 직접 수정할 수 없도록 설계** 필요

#### 🧩 증명자 제약 구조

- 증명자는 `g^{l(s)}`와 `g^{\alpha l(s)}`만 제시 가능
- 알파-시프트(α-shift) 구조로 인해 **같은 비율(scale)만 유지 가능**
- 예: `v·l(x)`는 가능하지만, `l(x)+c`나 `l(x)·u(x)`는 불가능 (비례 유지 안됨, pairing 불가)

---

### **4.6: Variable Polynomials**

#### 📌 확장 목적

- 이제는 다항식을 변수 단위로 분리하여 보다 복잡한 연산을 지원할 수 있도록 함

---

### **4.6.1: Single-Variable Operand Polynomial**

#### 🧠 의도

- 다항식 `l(x)`가 x=1,2,3 위치에서 동일한 값 `a`를 나타내도록 강제
- 이를 위해 다항식은 오직 전체 구조만 scale 가능해야 함 (계수는 개별 조작 불가)
- 증명자는 `l(x)`의 계수를 바꾸지 않고, 전체를 `v`배 scale만 가능 (암호화된 상태에선 덧셈/곱셈 불가)

---

### **4.6.2: Multi-Variable Operand Polynomial**

#### 📌 문제 상황

- 서로 다른 연산에서 서로 다른 변수를 사용하는 경우

  - 예: x=1,2에서는 `a`, x=3에서는 `d` 사용

#### ✅ 해결 전략: 변수별 다항식 분리 후 합산

- `l_a(x)`와 `l_d(x)`를 만들어서,

  - `l_a(x)`는 x=1,2에서 1, x=3에서 0
  - `l_d(x)`는 x=1,2에서 0, x=3에서 1

- `l(x) = a·l_a(x) + d·l_d(x)`로 표현

  - → x=1,2에서는 `a`, x=3에서는 `d`가 들어감

- 이 방식은 다항식을 변수 단위로 분해하여 각 변수의 영향 범위를 지정하는 방식

---

### ✅ 핵심 제약 요약

| 제약 항목           | 이유             | 설명                                               |
| ------------------- | ---------------- | -------------------------------------------------- |
| 개별 계수 수정 불가 | 위조 방지        | α-shift 구조 때문에 지수의 직접 수정 불가          |
| 다항식 곱셈 불가    | 암호화 제약      | 암호화된 값끼리는 곱셈이 불가능함                  |
| scale만 가능        | 증명자 능력 제한 | 전체 다항식을 일정 비율로 조정하는 것은 허용됨     |
| 변수별 다항식 분리  | 독립 변수 표현   | 서로 다른 변수는 서로 다른 다항식으로 표현 후 합산 |
