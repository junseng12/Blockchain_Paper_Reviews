# 📘 zk-SNARK 학습 요약 (2025-05-26)

**범위:** Section 3.1 ~ 3.4 (Polynomial Proofs, Homomorphic Encryption, Polynomial Restriction)  
**출처:** [Why and How zk-SNARK Works (arXiv:1906.07221)](https://arxiv.org/abs/1906.07221)

---

## ✅ 핵심 학습 내용

### 1. Polynomial Evaluation (`3.1`)

- 증명자는 다항식 `p(x)`를 알고 있다고 주장
- 목표는 `p(x) = t(x) * h(x)` 구조가 성립함을 증명
- 검증자는 무작위 `r`을 선택해 t(r) 제공 → `p(r) = t(r) * h(r)` 비교
- ⚠️ 단점: `r`을 안다면 증명자가 거짓 p(x)도 만들 수 있음 → 보안 취약

---

### 2. Homomorphic Encryption (`3.3`)

- 암호화 함수: `E(m) = g^m mod p` (g는 공개된 생성자)
- 동형성 성질:
  - 덧셈: `E(a) * E(b) = E(a + b)`
  - 스칼라곱: `E(a)^k = E(k * a)`
- zk-SNARK에서:
  - 검증자가 `E(s^i) = g^{s^i}` 전달 (s는 비공개)
  - 증명자는 계수 `{c0, c1, c2, ...}`에 따라 계산:
    ```
    E(p(s)) = ∏ E(s^i)^ci = g^{p(s)}
    ```
  - s는 몰라도 `g^{p(s)}`는 계산 가능

---

### 3. Polynomial Restriction (`3.4`)

- 목적: 증명자가 검증자가 제공한 `E(s^i)`만 사용했는지 확인
- 방법:
  - 검증자가 `E(s^i)`와 `E(α * s^i)`도 함께 제공 (α는 검증자만 아는 랜덤값)
  - 증명자는:
    - `gp = g^{p(s)}`
    - `gp' = g^{α * p(s)}`
  - 검증자는 다음 확인:
    ```
    gp^α == gp'
    ```
- 이 관계가 성립하면, 증명자가 제공된 값만 사용했음을 확인할 수 있음

---

## 💡 오늘 중점적으로 고민한 질문 & 개념 정리

| 개념                                          | 주요 질문/이슈                                                |
| --------------------------------------------- | ------------------------------------------------------------- |
| g의 역할                                      | g는 공개된 생성자로, 암호화 대상은 지수 m임                   |
| 증명자는 s를 몰라도 어떻게 p(s)를 계산하는가? | 동형암호 성질을 이용해 `g^{s^i}`를 계수와 곱하여 계산         |
| g^{p(s)}는 무슨 의미?                         | 증명자가 `p(x)`를 알고 있음을 암호화된 상태로 표현한 것       |
| 검증자는 g^{p(s)}로 무엇을 아는가?            | 값 자체는 모르고, 그 계산이 정당한 흐름인지만 검증            |
| gh = g^{h(s)}는 어떻게 만드나?                | `p(x) / t(x)` 다항식 나눗셈을 통해 h(x) 추출 후 g^{h(s)} 계산 |

---

# 📘 zk-SNARK 학습 요약 (2025-06-04)

**범위:** Section 3.5 \~ 4.6.2 (Zero-Knowledge, Trusted Setup, Multi-Operation, Variable Polynomials)
**출처:** [Why and How zk-SNARK Works (arXiv:1906.07221)](https://arxiv.org/abs/1906.07221)

---

## ✅ 핵심 학습 내용

### 1. Zero-Knowledge 성질 부여 (`3.5`)

- 증명값 `g^{p(s)}`만 제공하면, 증명 내용이 유출될 수 있음
- **ZK 보장**을 위해 증명자 임의의 랜덤값 `δ`를 곱함
- 증명자는 다음을 제출:

  ```
  g^{δ·p(s)}, g^{α·δ·p(s)}, g^{δ·h(s)}
  ```

- 검증자는 pairing을 통해 다음 식 확인:

  ```
  e(g^{α·δ·p(s)}, g) = e(g^{δ·p(s)}, g^α)
  e(g^{δ·p(s)}, g) = e(g^{δ·h(s)}, g^{t(s)})
  ```

- ⇒ 암호화된 상태에서 올바른 연산이 이루어졌음을 확인하며, 실제 p(s)는 노출되지 않음

---

### 2. CRS & Trusted Setup (`3.6`)

- **CRS (Common Reference String)**: 미리 계산된 `g^{s^i}`, `g^{α·s^i}` 들의 집합
- 대화형 구조를 비대화형으로 바꾸기 위한 핵심 요소
- `Trusted Setup` 과정에서 증명자와 검증자가 공통의 참조값을 가지게 함

#### 주요 개념 요약:

| 항목            | 설명                                                  |
| --------------- | ----------------------------------------------------- |
| CRS             | `g^s`, `g^{s^2}` 등 고정된 다항식 평가 암호문 집합    |
| Trapdoor        | `s`를 알면 거짓 증명도 가능함 ⇒ 외부에 공개 금지      |
| 다자간 Ceremony | 여러 참가자가 `s_i`를 독립적으로 선택하여 신뢰도 확보 |
| Powers of Tau   | SNARK용 다항식 암호화를 위한 일반적 setup 프로토콜    |

---

### 3. Succinct Non-Interactive Argument (`3.7`)

- zk-SNARK은 결국 다음 식의 암호화된 증명을 목표로 함:

  ```
  p(x) = l(x) * r(x) - o(x)
  p(x) = t(x) * h(x)
  ```

- 각 다항식 `l(x), r(x), o(x)`에 대해 다음 암호문 생성:

  ```
  g^{δ·l(s)}, g^{δ·r(s)}, g^{δ·o(s)}
  g^{α·δ·l(s)}, g^{α·δ·r(s)}, g^{α·δ·o(s)}
  ```

- pairing 기반 검증식으로 제약 조건 확인

---

## 🧮 General-Purpose Proof 구조 (`4.1 ~ 4.4`)

### 4.1 Computation

- 회로의 제약을 다항식으로 표현:

  ```
  l(x)·r(x) = o(x) + t(x)·h(x)
  ```

### 4.2 Single Operation

- 단일 제약에 대해 각각 다항식 구성
- p(x) = l(x)·r(x) − o(x) 형태로 구성 후, pairing을 통해 증명

### 4.3 Enforcing Operation

- p(x) = t(x)·h(x)인지 검증해야 함
- 암호문만으로는 곱셈 불가 ⇒ pairing으로 제한 검증 수행

### 4.4 Proof of Operation

- 증명자는:

  ```
  g^{l(s)}, g^{r(s)}, g^{o(s)}, g^{α·l(s)}, g^{α·r(s)}, g^{α·o(s)}
  ```

  을 제출함

- 검증자는 pairing을 통해 위 다항식의 관계와 동일한 s 사용을 확인
- 알파 시프트(`α`)는 다항식 위조를 막는 역할

---

## 🧮 Multiple Operations & Variable Polynomials (`4.5 ~ 4.6.2`)

### 4.5.1 Polynomial Interpolation

- 여러 연산을 다항식 하나로 통합하려면 `t(x)`의 **근**이 각 연산 위치를 포함해야 함
- 예: 연산이 x=1, 2, 3에서 일어났다면:

  ```
  t(x) = (x - 1)(x - 2)(x - 3)
  ```

### 4.5.2 Multi-Operation Polynomials

- 하나의 다항식으로 여러 연산을 표현 가능하지만, 변수 간 독립성을 침해할 수 있음
- 동일한 `a`값을 모든 연산에서 보장하려면, 다항식의 \*\*비례성(proportion)\*\*만 유지해야 함

  - 즉, `v·l(x)`는 가능하지만 `l(x) + u(x)`는 불가 (pairing 전에 암호화 상태에선 곱셈 안됨)

### 4.6.1 Single-Variable Operand Polynomial

- `l(x)` 다항식이 하나의 변수 `a`만 반영할 때, x=1,2,3 모두 동일한 값 `a`여야 함
- 하지만 prover가 각 위치에서 다른 값을 대입하면 부정확한 증명이 됨 ⇒ 막아야 함
- **해결책**: `g^{l(s)}`와 `g^{α·l(s)}`를 함께 검증하여, 하나의 l(x)에 대해 증명했음을 보장

### 4.6.2 Multi-Variable Operand Polynomial

- 서로 다른 변수 (a, d 등)를 다룰 경우 `l_a(x)`, `l_d(x)` 등의 **변수 다항식**을 개별 정의
- 예:

  - `l_a(x)`는 x=1,2에서 1, 나머지 0
  - `l_d(x)`는 x=3에서 1, 나머지 0

- 각각의 다항식에 값 곱하고 합산하면, 다항식이 전체 연산을 표현함:

  ```
  l(x) = a·l_a(x) + d·l_d(x)
  ```

- 이로써 변수별 독립성과 ZK 보장 유지

---

## 💡 오늘 중점적으로 고민한 질문 & 개념 정리

| 개념                                        | 질문/이슈                                                        |
| ------------------------------------------- | ---------------------------------------------------------------- |
| 왜 g^{a·b}는 계산이 불가능한가?             | 지수의 곱은 일반적인 암호화 연산에서 불가능 → pairing으로 우회함 |
| 왜 증명자는 다항식 계수를 변경할 수 없는가? | α 시프트가 없이는 다항식의 각 항목을 독립적으로 조작 불가함      |
| 왜 동일 변수는 하나의 값을 가져야 하는가?   | 동일 입력에 대해 회로 전체가 하나의 일관된 흐름을 갖기 위해 필요 |
| 왜 u(x)로 곱하면 위험한가?                  | 다항식 비율이 깨지면, 전체 구조를 변경할 수 있어 위조 우려 발생  |
| 변수 분리의 목적은?                         | 다수 연산을 다룰 때, 변수마다 독립적 제약을 부여하기 위함        |

---
