# 📘 β shift 구조 발전 핵심 개념

$$
\text{목적: 동일한 변수 v가 L, R, O에서 동일한 값으로 쓰였는가?}
$$

---

## 🎯 WHY: β shift가 필요한 이유

- 하나의 변수 `v`가 여러 위치에서 나타나는 경우 (예: L(x), R(x), O(x))
- Prover가 이 변수의 값을 **위치마다 다르게 조작**하여 제약 조건을 위반할 수 있음

→ **변수 값의 일관성을 보장해야 함**

---

## ✅ 1단계: 단일 β 구조 (Single β Shift)

### 📌 구조

- 모든 위치(L, R, O)에 대해 **하나의 β** 사용
- 증명자는 다음과 같은 pairing 검증을 만족해야 함:

$$
e(g^{v_l} \cdot g^{v_r} \cdot g^{v_o}, g^{\beta}) \overset{?}{=} e(g^{v_\beta}, g^{\beta \cdot (l_i(s) + r_i(s) + o_i(s))})
$$

### ✅ 목적

| 항목              | 설명                                                    |
| ----------------- | ------------------------------------------------------- |
| 단일 β 사용       | 하나의 pairing으로 L, R, O 위치의 동일 변수 여부를 검증 |
| consistency check | 증명자가 변수마다 동일한 값을 사용했는지 검증 가능      |

### ⚠️ 한계

- 단일 β이기 때문에 **수학적 관계만 만족하면 다른 값으로 대입해도 pairing 통과 가능**
- 예:
  $v_l = 2v_o - v_r,\quad v_\beta = v_o$
  → 좌변 = 우변 만족하게 설정 가능
  → **수학적 “우회 조작” 가능성 존재**

---

## ✅ 2단계: 랜덤 β 구조 (Randomized βₗ, βᵣ, βₒ)

### 📌 구조

- L, R, O 각각에 대해 **서로 다른 β 값 사용**: βₗ, βᵣ, βₒ
- 증명자는 consistency polynomial $Z_i(s)$를 제출:

$$
Z_i(s) = \left(l_i(s) \cdot \beta_l + r_i(s) \cdot \beta_r + o_i(s) \cdot \beta_o\right) \cdot v_i
$$

- 이를 증명자는 pairing으로 제출하고, 검증자는 다음을 확인:

$$
e(g^{v_l}, g^{\beta_l}) \cdot e(g^{v_r}, g^{\beta_r}) \cdot e(g^{v_o}, g^{\beta_o}) = e(g^{v_\beta}, g^{\beta_l l_i(s) + \beta_r r_i(s) + \beta_o o_i(s)})
$$

### ✅ 개선점

| 항목                | 설명                                                                                |
| ------------------- | ----------------------------------------------------------------------------------- |
| β 값 분리           | L, R, O에 서로 다른 random β 적용                                                   |
| 우회 조작 방지 강화 | 증명자가 세 위치의 β 조합을 **역산 불가**하게 만들어 consistency 조작을 어렵게 만듦 |

### ⚠️ 여전히 남은 한계

- β 값들은 여전히 $g^{\beta_l}, g^{\beta_r}, g^{\beta_o}$ 형태로 CRS에 공개되어 있음
- 증명자는 직접 지수는 모르지만 pairing의 **동형성** 때문에:

  - L(s), R(s), O(s)의 **상수항 (x⁰항)** 조작으로 Z(s) 결과를 맞추는 우회 가능성 존재

- → **Z(s)** = (잘 설계된 L, R, O 조작)으로 만들어서 pairing 우변에 맞춤 가능

---

## ✅ 3단계: γ 마스킹 구조 (4.9.3)

### 📌 구조

- 새로운 난수 γ 생성
- 모든 pairing 검증에 γ를 곱해서 지수 부분을 **난독화**
- 검증자는 다음 pairing을 확인:

$$
e(g^{L(s)}, g^{\beta_l \cdot \gamma}) \cdot e(g^{R(s)}, g^{\beta_r \cdot \gamma}) \cdot e(g^{O(s)}, g^{\beta_o \cdot \gamma}) = e(g^{Z(s)}, g^{\gamma})
$$

### ✅ 개선점

| 항목                | 설명                                                            |
| ------------------- | --------------------------------------------------------------- |
| pairing 우변 난독화 | 결과값 Z(s)조차 γ 때문에 예측 불가                              |
| Z(s) 조작 불가능    | 증명자는 γ를 모르므로, pairing 통과하도록 조작 불가             |
| 베타 공개 무력화    | g^βₗ 등만 공개된 상태에서 pairing 결과 예측이 원천적으로 차단됨 |

---

## ✅ 최종 요약 정리표

| 단계              | 구조        | 검증 구성                                                                | 보안 목표                   | 남은 위험             |
| ----------------- | ----------- | ------------------------------------------------------------------------ | --------------------------- | --------------------- |
| ① 단일 β          | β 하나      | $e(g^{v_l v_r v_o}, g^\beta) = e(g^{v_\beta}, g^{\beta(l+r+o)})$         | 변수 값 일관성 보장         | 수학적 우회 조작 가능 |
| ② 랜덤 βₗ, βᵣ, βₒ | 서로 다른 β | $e(g^{L}, g^{βₗ}) \cdot e(g^R, g^{βᵣ}) \cdot e(g^O, g^{βₒ}) = e(g^Z, g)$ | 베타 관계 강화, 우회 어려움 | 상수항 조작 여지      |
| ③ γ 마스킹        | β \* γ      | $e(g^L, g^{βₗγ}) \cdot ... = e(g^Z, g^γ)$                                | pairing 결과 예측 불가      | 없음 (Z(s) 조작 불가) |

---

## 🧠 한 문장 요약

> **β shift는 변수 간 일관성 검증을 위한 구조이며, β randomization + γ 마스킹을 통해 ZK 증명의 조작 불가능성(Non-malleability)을 완성한다.**

---
