# 🧠 이더리움 샤딩 리마스터 리뷰

> 이 문서는 샤딩의 구조적 이해와 함께, 실제 학습 과정에서의 질문과 이해 포인트를 함께 정리한 통합 문서입니다.

---

## 1. 🧱 샤딩의 기본 구조와 작동 방식

샤딩은 이더리움 L1을 **여러 개의 병렬 샤드 체인으로 분할**하여 확장성과 처리 속도를 높이기 위한 기술입니다. 각 샤드는 독립적으로 블록을 생성하고 데이터를 검증/저장할 수 있습니다.

비콘 체인은 샤드 체인의 상태 요약값(헤더, 루트)을 수집하고 최종성을 보장하는 중앙 조율자 역할을 합니다.

```
[사용자 TX] → [비콘 체인: 샤드 배정] → [샤드: 블록 생성 및 저장]
                            ↓
               [비콘 체인: 상태 루트 통합]
```

🔍 **실전 인사이트**

- 질문: _샤드는 블록을 만들기만 하나? 저장도 하나?_
- 답변: 샤드는 블록을 **직접 생성하고 저장**합니다. 다만, L1에는 **헤더 요약값만 전파**합니다.

---

## 2. 🧪 검증자 위원회와 보안: 랜덤 샘플링

### ✅ 랜덤 샘플링

검증자들을 무작위로 섞어 샤드별로 위원회(committee)를 구성함으로써, 특정 샤드를 악의적으로 장악하는 것을 방지합니다.

🔍 **실전 인사이트**

- 질문: _30% 악의적 검증자면 샤드 장악 가능한가?_
- 답변: **랜덤 샘플링이 없다면 가능성 있음**, 있지만 샘플링이 있으면 침투 가능성 급감.

---

## 3. 🔎 왜 샤딩은 ‘데이터 가용성 레이어’인가?

샤드는 **데이터 저장과 전파** 역할에 집중하며, **스마트 컨트랙트 실행은 L1에서만 수행**합니다.

### 🧠 이유:

- 스마트 컨트랙트는 메시지 호출, 상태 전이 등 복잡한 처리 → 샤드 간 상태 공유 어려움
- 샤드 독립성 보장 어려움
- L1에서 처리해야 신뢰성 확보 가능

🔍 **실전 인사이트**

- 질문: _샤드에서 스마트 컨트랙트 실행 못 해?_
- 답변: 기술적으로 가능하지만, 복잡도와 상태 동기화 문제로 L1에서 처리하는 게 안전.

---

## 4. 💡 블록 생성 vs. TX 검증: 흐름 정리

| 단계              | 주체             | 설명                         |
| ----------------- | ---------------- | ---------------------------- |
| TX 생성           | 사용자           | TX 전송                      |
| 샤드 배정         | 비콘 체인        | TX를 적절한 샤드로 라우팅    |
| TX 검증           | 샤드 내 위원회   | 해당 샤드의 TX만 검증        |
| 블록 생성 및 저장 | 샤드             | 여러 TX를 블록으로 구성      |
| 헤더 전파         | 샤드 → 비콘 체인 | 상태 루트, Merkle Root 전송  |
| 최종성 기록       | 비콘 체인        | 블록의 합의 및 Finality 기록 |

---

## 5. 📦 데이터 가용성 (DAS), 낚시꾼 딜레마, Merkle Proof

### ✅ 낚시꾼 딜레마

- 데이터가 유포되지 않아도 유포되었다고 주장 가능
- 외부자는 진위 판단 어려움

### ✅ DAS (Data Availability Sampling)

- 모든 데이터를 받지 않고 일부만 요청하여 유포 여부 판단
- 다수가 무작위 요청하면 거짓 유포 탐지 가능

### ✅ Erasure Coding

- 블록을 N개로 나누고, K개만으로 복원 가능
- 일부만 퍼져 있어도 전체 복원 가능

🔍 **실전 인사이트**

- 질문: _해당 chunk만 있다고 해서 전체 데이터가 있다고 볼 수 있어?_
- 답변: Erasure coding과 다수의 샘플링을 통해 **확률적으로 신뢰 가능**.

---

## 6. 📁 Merkle Proof와 데이터 요청

Merkle Proof는 블록 안에 TX가 **포함되었음을 증명**할 수 있음. 하지만 실제 실행하려면 데이터를 **직접 샤드에서 Pull**해 와야 함.

🔍 **실전 인사이트**

- 질문: _왜 존재 증명만 하고 데이터를 직접 주지 않아?_
- 답변: 존재만 입증되면 L1은 해당 샤드에서 데이터를 다시 요청해 처리함.

---

## 7. 🧬 전체 실행 흐름 정리

```
[사용자 TX]
   ↓
[비콘 체인: 샤드로 배정]
   ↓
[샤드: TX 검증, 블록 생성, 저장]
   ↓
[헤더 전파 → 비콘 체인]
   ↓
[최종성(Finality) 기록 + 상태 루트]
   ↓
[L1 실행자: Merkle Proof로 존재 확인]
   ↓
[샤드에서 데이터 Pull → 실행]
```

---

## 📌 질문으로 배우는 샤딩 요약

| 질문                              | 개념 연결                           |
| --------------------------------- | ----------------------------------- |
| 샤드는 저장도 하나?               | 예, 블록을 생성하고 저장함          |
| 왜 실행은 L1에서 하나?            | 상태 동기화 및 보안 문제            |
| Merkle Proof로는 뭐만 알 수 있나? | 트랜잭션 포함 여부 (존재성만)       |
| 실제 데이터는 누가 받나?          | L1에서 샤드로부터 Pull              |
| 샘플링만으로 충분한가?            | 다수 요청 + Erasure coding으로 가능 |

---

## 🔗 참고 자료

- Xangle 리서치: https://xangle.io/research/detail/489
- Vitalik Buterin: DAS와 데이터 전파 전략
