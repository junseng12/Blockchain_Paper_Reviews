## 📌 **1️⃣ What is a smart contract?**

In Ethereum, there are **two types of accounts**.

- **EOA (Externally Owned Account)**
- Accounts controlled directly by users (using private keys)
- Can call contracts through transactions
- Example: Accounts managed by wallets such as Metamask and Ledger
- **CA (Contract Account)**
- Accounts that **run code on their own** (no private keys)
- Immutable after deployment
- Can only be executed through transactions
➡️ **In other words, a smart contract is a contract account (CA) where code is executed.**
<summary>Features and structure of Solidity</summary>
Solidity is a **high-level programming language** created for writing Ethereum smart contracts.

- **Object-oriented programming (OOP) based**
- **JavaScript/C++-like syntax**
- **Compiled into bytecode that runs on the Ethereum Virtual Machine (EVM)**

---

## 📌 **2️⃣ Key attributes of smart contracts**

| Attribute                                                 | Description                                                 |
| --------------------------------------------------------- | ----------------------------------------------------------- |
| **Immutability**                                          | Code cannot be changed after deployment                     |
| **Deterministic execution**                               | Same input → Same result                                    |
| **Decentralized execution**                               | Same code executed on all nodes                             |
| **Gas cost**                                              | Gas cost incurred for each execution                        |
| **Trigger-based Execution (Transaction-based execution)** | Does not execute directly; execution requires a transaction |
| **No Private Key (No private key)**                       | Unlike EOAs, contract accounts do not have private keys     |

## 📌 **In other words, contracts do not execute on their own; they are executed by transactions generated by EOAs!**

## 📌 **3️⃣ Smart Contract Life Cycle**

Smart contracts consist of **four stages**.

### 🔹 1) Writing & Compiling

- Write Solidity code → Convert to bytecode using `solc`.
- **ABI (Application Binary Interface) is generated** during compilation.

```solidity
pragma solidity ^0.8.0;
  contract Faucet {
      function withdraw(uint withdraw_amount) public {
          payable(msg.sender).transfer(withdraw_amount);
      }
      receive() external payable {} // Can receive ether
  }
```

- `solc --bin Faucet.sol` → Outputs bytecode
- `solc --abi Faucet.sol` → Outputs ABI

### 🔹 2) Deployment

- **Create a deployment transaction (Contract Creation Transaction)**
- The `to` field is `null`
- The contract address is determined by combining **(deployer address + nonce)**.

```solidity
  const tx = {
    from: “0xYourEOAAddress”,
          to: null,  // Set to null because it is contract deployment
    data: “0x6080604052348015600...”,  // Bytecode
    gas: 3000000,
    gasPrice: web3.utils.toWei(‘20’, ‘gwei’)
  };
  web3.eth.sendTransaction(tx);
```

### 🔹 3) Execution

- The contract is executed only when the EOA sends a transaction.
- Contracts can call each other (Nested Execution)

### 🔹 4) Selfdestruct

- The contract is deleted when `selfdestruct(address)` is called.
- The only way to permanently delete data on Ethereum.

```solidity
function destroy() public {
    require(msg.sender == owner, “Only owner can destroy”);
    selfdestruct(payable(owner));
}
```

## 📌 **However, past transaction records remain on the blockchain!**

## 📌 **5️⃣ Gas and Gas Optimization**

### 💰 **What is Gas?**

- **The cost of executing a transaction on Ethereum.**
- **1 Gas ≠ 1 ETH**, gas is converted to ETH units by `gasPrice`.

### 🔥 **Gas Cost Example**

| Operation                       | Cost       |
| ------------------------------- | ---------- |
| `SSTORE` (storage update)       | 20,000 gas |
| `CALL` (external contract call) | 700 gas    |
| `ADD` (addition)                | 3 gas      |
| `JUMPDEST` (jump location)      | 1 gas      |

📌 **The more complex the operation, the more gas is consumed!**

### ✅ **Gas optimization methods**

1. **Use memory instead of storage** (reduces storage access cost)
2. **Use `calldata`** (reduces cost compared to `memory`)
3. **Minimize loops** (use `mapping` instead of `for`)
4. **Minimize reading state variables** (reduce `uint` to `uint8`)

---

## 📌 **6️⃣ Security considerations in Solidity**

Security vulnerabilities in Solidity can lead to **direct financial losses**.

### ⚠️ **Reentrancy Attack**

- When sending Ether from a contract, an attacker can make multiple withdrawals by recursive calls.

```solidity
function withdraw(uint _amount) public {
    require(balances[msg.sender] >= _amount, “Insufficient balance”);
    payable(msg.sender).transfer(_amount);

balances[msg.sender] -= _amount;  // 🔥 Problem occurs!
}
```

✅ **Solution**

- Use `call.value` instead of `transfer()`
- Perform state changes first (apply the `checks-effects-interactions` pattern)4
<summary>✅ **Explain reentrancy attacks using an analogy**</summary>
**💡 Analogy:**
Let's assume you are withdrawing money from a bank.
- Bank teller: “I'll confirm the withdrawal request, transfer the requested amount to the customer, and then update the balance!”
- But what if the customer sends another withdrawal request while the first request is being processed?
- In this case, if the bank system **processes multiple withdrawal requests before updating the balance**, what would happen?
  → The customer could **withdraw more money than the actual balance**! 💸💸💸

```solidity
function withdraw(uint _amount) public {
    require(balances[msg.sender] >= _amount, “Insufficient balance”);

balances[msg.sender] -= _amount;  // ✅ Change state first!
    payable(msg.sender).transfer(_amount);
}
```

### ⚠️ **Integer Overflow & Underflow**

- Automatically prevented in Solidity 0.8 and above.

```solidity
// SafeMath is required in Solidity 0.7 and below!
using SafeMath for uint256;
```

---

## **7️⃣ Using Events in Smart Contracts**

Event: **A method for recording transaction logs (logs)**

### ✅ **Event declaration and usage example**

```solidity
contract Example {

event Transferred(address indexed _from, address indexed _to, uint _value);
    function send(address _to, uint _value) public {
        emit Transferred(msg.sender, _to, _value);
    }
}
```

- When you trigger an event using `emit`, it is **recorded in the transaction log**
- You can view the event using a block explorer such as Etherscan

## 📌 msg.sender VS. tx.origin

## 🎭 **Analogy: Company president (EOA), manager (A), employee (B)**

**Situation**

- Let's say there is a company (Ethereum network).
- The CEO (EOA) instructs the manager (A) to “Ask employee (B) for the materials.”
- The manager (A) goes to the employee (B) and says, “The CEO asked you for the materials.”

---

### 🔹 **Expressed in Solidity code:**

```solidity
contract A {
    function callB(address _b) public {
      B(_b).someFunction();  // A calls B
    }
}
```

1️⃣ **CEO (EOA)** → Sends a transaction to manager (A) saying, “Call someFunction() on B.”
2️⃣ **Manager (A)** → Executes employee (B)'s `someFunction()`.

---

## 🕵️‍♂️ **At this point,** **`msg.sender`\*\*** and\*\* **`tx.origin`** \*\*values

| Variable                            | Meaning                                  | Value       |
| ----------------------------------- | ---------------------------------------- | ----------- |
| `tx.origin`                         | The person who initiated the transaction | CEO (EOA)   |
| `msg.sender` (from B's perspective) | The contract that called it              | A (Manager) |

In other words, from the perspective of smart contract `B`:

- `msg.sender` = Manager `A`
- `tx.origin` = CEO `EOA`

---

## 🔥 **Key points**

- **`msg.sender`\*\*** is the immediate caller\*\*
  → Since A called B, `msg.sender` is A from B's perspective
- **`tx.origin`\*\*** is the EOA that initiated the first transaction\*\*

## → Since the CEO (EOA) initiated all these calls, `tx.origin` is still EOA

## ⚠️ **Security Issue:** **Using `tx.origin` is dangerous!**

If a malicious contract uses `tx.origin` as a validation condition, an attacker can trick it by calling it through another contract.

```solidity
contract Malicious {
    function attack(Victim victim) public {
        victim.withdrawAll(); // Execute the Victim contract
    }
}
contract Victim {
    function withdrawAll() public {
        require(tx.origin == owner, “Not owner!”); // Verify tx.origin ❌ (dangerous!)
        payable(msg.sender).transfer(address(this).balance);
    }
}
```

- If the Victim contract uses `tx.origin == owner`, **even if the attacker calls it through an intermediate contract (Malicious),** **`tx.origin`\*\*** will still be the original EOA (victim)\*\*\*\*.
- Therefore, **verification using only msg.sender is required for safety**.

---

### 🔥 **Conclusion: Why is **`tx.origin`\*\*\*\* dangerous?\*\*

1️⃣ Using `tx.origin` makes it **impossible to detect attackers even if a malicious contract intervenes in the middle.**

2️⃣ If `msg.sender` is used, when a malicious contract requests a withdrawal, `msg.sender == malicious contract` is true, so it can be blocked.

3️⃣ Therefore, **always** use **`msg.sender`\*\***, and **`tx.origin`\*\*** is vulnerable to security risks, so it is best not to use it!\*\* 🚀
