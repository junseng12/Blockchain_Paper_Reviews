## ğŸ“Œ **1ï¸âƒ£ What is a smart contract?**

In Ethereum, there are **two types of accounts**.

- **EOA (Externally Owned Account)**
- Accounts controlled directly by users (using private keys)
- Can call contracts through transactions
- Example: Accounts managed by wallets such as Metamask and Ledger
- **CA (Contract Account)**
- Accounts that **run code on their own** (no private keys)
- Immutable after deployment
- Can only be executed through transactions
â¡ï¸ **In other words, a smart contract is a contract account (CA) where code is executed.**
<summary>Features and structure of Solidity</summary>
Solidity is a **high-level programming language** created for writing Ethereum smart contracts.

- **Object-oriented programming (OOP) based**
- **JavaScript/C++-like syntax**
- **Compiled into bytecode that runs on the Ethereum Virtual Machine (EVM)**

---

## ğŸ“Œ **2ï¸âƒ£ Key attributes of smart contracts**

| Attribute                                                 | Description                                                 |
| --------------------------------------------------------- | ----------------------------------------------------------- |
| **Immutability**                                          | Code cannot be changed after deployment                     |
| **Deterministic execution**                               | Same input â†’ Same result                                    |
| **Decentralized execution**                               | Same code executed on all nodes                             |
| **Gas cost**                                              | Gas cost incurred for each execution                        |
| **Trigger-based Execution (Transaction-based execution)** | Does not execute directly; execution requires a transaction |
| **No Private Key (No private key)**                       | Unlike EOAs, contract accounts do not have private keys     |

## ğŸ“Œ **In other words, contracts do not execute on their own; they are executed by transactions generated by EOAs!**

## ğŸ“Œ **3ï¸âƒ£ Smart Contract Life Cycle**

Smart contracts consist of **four stages**.

### ğŸ”¹ 1) Writing & Compiling

- Write Solidity code â†’ Convert to bytecode using `solc`.
- **ABI (Application Binary Interface) is generated** during compilation.

```solidity
pragma solidity ^0.8.0;
  contract Faucet {
      function withdraw(uint withdraw_amount) public {
          payable(msg.sender).transfer(withdraw_amount);
      }
      receive() external payable {} // Can receive ether
  }
```

- `solc --bin Faucet.sol` â†’ Outputs bytecode
- `solc --abi Faucet.sol` â†’ Outputs ABI

### ğŸ”¹ 2) Deployment

- **Create a deployment transaction (Contract Creation Transaction)**
- The `to` field is `null`
- The contract address is determined by combining **(deployer address + nonce)**.

```solidity
  const tx = {
    from: â€œ0xYourEOAAddressâ€,
          to: null,  // Set to null because it is contract deployment
    data: â€œ0x6080604052348015600...â€,  // Bytecode
    gas: 3000000,
    gasPrice: web3.utils.toWei(â€˜20â€™, â€˜gweiâ€™)
  };
  web3.eth.sendTransaction(tx);
```

### ğŸ”¹ 3) Execution

- The contract is executed only when the EOA sends a transaction.
- Contracts can call each other (Nested Execution)

### ğŸ”¹ 4) Selfdestruct

- The contract is deleted when `selfdestruct(address)` is called.
- The only way to permanently delete data on Ethereum.

```solidity
function destroy() public {
    require(msg.sender == owner, â€œOnly owner can destroyâ€);
    selfdestruct(payable(owner));
}
```

## ğŸ“Œ **However, past transaction records remain on the blockchain!**

## ğŸ“Œ **5ï¸âƒ£ Gas and Gas Optimization**

### ğŸ’° **What is Gas?**

- **The cost of executing a transaction on Ethereum.**
- **1 Gas â‰  1 ETH**, gas is converted to ETH units by `gasPrice`.

### ğŸ”¥ **Gas Cost Example**

| Operation                       | Cost       |
| ------------------------------- | ---------- |
| `SSTORE` (storage update)       | 20,000 gas |
| `CALL` (external contract call) | 700 gas    |
| `ADD` (addition)                | 3 gas      |
| `JUMPDEST` (jump location)      | 1 gas      |

ğŸ“Œ **The more complex the operation, the more gas is consumed!**

### âœ… **Gas optimization methods**

1. **Use memory instead of storage** (reduces storage access cost)
2. **Use `calldata`** (reduces cost compared to `memory`)
3. **Minimize loops** (use `mapping` instead of `for`)
4. **Minimize reading state variables** (reduce `uint` to `uint8`)

---

## ğŸ“Œ **6ï¸âƒ£ Security considerations in Solidity**

Security vulnerabilities in Solidity can lead to **direct financial losses**.

### âš ï¸ **Reentrancy Attack**

- When sending Ether from a contract, an attacker can make multiple withdrawals by recursive calls.

```solidity
function withdraw(uint _amount) public {
    require(balances[msg.sender] >= _amount, â€œInsufficient balanceâ€);
    payable(msg.sender).transfer(_amount);

balances[msg.sender] -= _amount;  // ğŸ”¥ Problem occurs!
}
```

âœ… **Solution**

- Use `call.value` instead of `transfer()`
- Perform state changes first (apply the `checks-effects-interactions` pattern)4
<summary>âœ… **Explain reentrancy attacks using an analogy**</summary>
**ğŸ’¡ Analogy:**
Let's assume you are withdrawing money from a bank.
- Bank teller: â€œI'll confirm the withdrawal request, transfer the requested amount to the customer, and then update the balance!â€
- But what if the customer sends another withdrawal request while the first request is being processed?
- In this case, if the bank system **processes multiple withdrawal requests before updating the balance**, what would happen?
  â†’ The customer could **withdraw more money than the actual balance**! ğŸ’¸ğŸ’¸ğŸ’¸

```solidity
function withdraw(uint _amount) public {
    require(balances[msg.sender] >= _amount, â€œInsufficient balanceâ€);

balances[msg.sender] -= _amount;  // âœ… Change state first!
    payable(msg.sender).transfer(_amount);
}
```

### âš ï¸ **Integer Overflow & Underflow**

- Automatically prevented in Solidity 0.8 and above.

```solidity
// SafeMath is required in Solidity 0.7 and below!
using SafeMath for uint256;
```

---

## **7ï¸âƒ£ Using Events in Smart Contracts**

Event: **A method for recording transaction logs (logs)**

### âœ… **Event declaration and usage example**

```solidity
contract Example {

event Transferred(address indexed _from, address indexed _to, uint _value);
    function send(address _to, uint _value) public {
        emit Transferred(msg.sender, _to, _value);
    }
}
```

- When you trigger an event using `emit`, it is **recorded in the transaction log**
- You can view the event using a block explorer such as Etherscan

## ğŸ“Œ msg.sender VS. tx.origin

## ğŸ­ **Analogy: Company president (EOA), manager (A), employee (B)**

**Situation**

- Let's say there is a company (Ethereum network).
- The CEO (EOA) instructs the manager (A) to â€œAsk employee (B) for the materials.â€
- The manager (A) goes to the employee (B) and says, â€œThe CEO asked you for the materials.â€

---

### ğŸ”¹ **Expressed in Solidity code:**

```solidity
contract A {
    function callB(address _b) public {
      B(_b).someFunction();  // A calls B
    }
}
```

1ï¸âƒ£ **CEO (EOA)** â†’ Sends a transaction to manager (A) saying, â€œCall someFunction() on B.â€
2ï¸âƒ£ **Manager (A)** â†’ Executes employee (B)'s `someFunction()`.

---

## ğŸ•µï¸â€â™‚ï¸ **At this point,** **`msg.sender`\*\*** and\*\* **`tx.origin`** \*\*values

| Variable                            | Meaning                                  | Value       |
| ----------------------------------- | ---------------------------------------- | ----------- |
| `tx.origin`                         | The person who initiated the transaction | CEO (EOA)   |
| `msg.sender` (from B's perspective) | The contract that called it              | A (Manager) |

In other words, from the perspective of smart contract `B`:

- `msg.sender` = Manager `A`
- `tx.origin` = CEO `EOA`

---

## ğŸ”¥ **Key points**

- **`msg.sender`\*\*** is the immediate caller\*\*
  â†’ Since A called B, `msg.sender` is A from B's perspective
- **`tx.origin`\*\*** is the EOA that initiated the first transaction\*\*

## â†’ Since the CEO (EOA) initiated all these calls, `tx.origin` is still EOA

## âš ï¸ **Security Issue:** **Using `tx.origin` is dangerous!**

If a malicious contract uses `tx.origin` as a validation condition, an attacker can trick it by calling it through another contract.

```solidity
contract Malicious {
    function attack(Victim victim) public {
        victim.withdrawAll(); // Execute the Victim contract
    }
}
contract Victim {
    function withdrawAll() public {
        require(tx.origin == owner, â€œNot owner!â€); // Verify tx.origin âŒ (dangerous!)
        payable(msg.sender).transfer(address(this).balance);
    }
}
```

- If the Victim contract uses `tx.origin == owner`, **even if the attacker calls it through an intermediate contract (Malicious),** **`tx.origin`\*\*** will still be the original EOA (victim)\*\*\*\*.
- Therefore, **verification using only msg.sender is required for safety**.

---

### ğŸ”¥ **Conclusion: Why is **`tx.origin`\*\*\*\* dangerous?\*\*

1ï¸âƒ£ Using `tx.origin` makes it **impossible to detect attackers even if a malicious contract intervenes in the middle.**

2ï¸âƒ£ If `msg.sender` is used, when a malicious contract requests a withdrawal, `msg.sender == malicious contract` is true, so it can be blocked.

3ï¸âƒ£ Therefore, **always** use **`msg.sender`\*\***, and **`tx.origin`\*\*** is vulnerable to security risks, so it is best not to use it!\*\* ğŸš€
