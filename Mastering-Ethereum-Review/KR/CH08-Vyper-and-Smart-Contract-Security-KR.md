## 1️⃣ **Vyper란? 왜 만들었을까?**

Vyper는 **Ethereum Virtual Machine(EVM)**에서 실행되는 **스마트 컨트랙트**를 작성하기 위한 언어다. 기존의 Solidity보다 **보안성, 가독성, 감사 용이성**을 높이기 위해 설계되었다. 특히, **"개발자가 실수로 취약한 코드를 작성하는 것을 최대한 어렵게 만드는 것"**이 Vyper의 핵심 철학이다.

💡 **Vyper의 주요 설계 철학**

1. **코드를 최대한 직관적으로 유지** → 사람이 읽기 쉽게 작성되어야 함.
2. **보안성을 최우선으로 고려** → 취약점을 유발하는 기능을 아예 제거.
3. **감사(Audit)가 쉬운 구조** → 코드 흐름이 명확하게 보이도록 함.

## 2️⃣ **Solidity의 주요 보안 문제점과 Vyper의 접근 방식**

Solidity에서는 많은 스마트 컨트랙트가 **예기치 않은 취약점**으로 인해 해킹당하는 사례가 있었다. 연구에 따르면 배포된 스마트 컨트랙트 중 상당수가 다음과 같은 취약점을 가지고 있었다.

### 📌 **💀 Solidity에서 발생하는 3가지 주요 취약점**

| 취약점 종류            | 설명                                | 예시                                                |
| ---------------------- | ----------------------------------- | --------------------------------------------------- |
| **Suicidal Contracts** | 아무나 컨트랙트를 삭제 가능         | `selfdestruct()`을 누구나 실행할 수 있도록 설계됨   |
| **Greedy Contracts**   | 일정 조건에서 이더를 출금할 수 없음 | `require()` 조건이 충족되지 않아 영원히 자금이 묶임 |
| **Prodigal Contracts** | 공격자가 무단으로 이더를 출금 가능  | 잘못된 접근 제어로 인해 아무나 출금 가능            |

**Vyper는 이러한 문제를 방지하기 위해, 취약점을 유발하는 기능들을 아예 지원하지 않는다.**

---

## 3️⃣ **Vyper vs Solidity 비교**

Vyper는 Solidity와 다르게 **몇 가지 기능을 의도적으로 제거**했다. 그 이유는 **보안 강화를 위해 개발자가 실수할 가능성을 줄이기 위해서**다.

### 🔍 **Vyper에서 제거된 기능과 그 이유**

| Solidity 기능            | Vyper에서 제거된 이유                                | 예시                                                                     |
| ------------------------ | ---------------------------------------------------- | ------------------------------------------------------------------------ |
| **Modifiers**            | 숨겨진 로직이 포함될 가능성이 있음                   | `onlyOwner` 같은 권한 제어를 직접 함수에 작성해야 함                     |
| **Class Inheritance**    | 코드 흐름이 복잡해지고 감사(Audit)가 어려움          | `contract A is B` 같은 상속 기능 없음                                    |
| **Inline Assembly**      | EVM의 저수준 명령어를 직접 실행 가능 → 보안 취약     | `assembly { mstore(0x40, add(mload(0x40), 0x20)) }` 같은 코드 불가       |
| **Function Overloading** | 같은 이름의 함수가 여러 개 있을 경우 가독성이 떨어짐 | `function add(uint a) {...}` / `function add(uint a, uint b) {...}` 불가 |
| **Implicit Typecasting** | 변환 과정에서 데이터 손실 가능성이 있음              | `uint32 → uint16` 변환 시 잘못된 데이터 발생 가능                        |

✅ **Vyper의 대안:**

- `Modifiers` 대신 함수 내부에서 직접 검증
- `Class Inheritance` 대신 명확한 코드 작성
- `Inline Assembly` 대신 표준 기능만 사용
- `Function Overloading` 없이 명확한 함수 이름 사용
- `Implicit Typecasting` 없이 명확한 `convert()` 함수 사용

## 4️⃣ **무한 루프 방지 (Infinite Loop Prevention)**

**Solidity에서는 개발자가 무한 루프를 작성할 수 있지만**, Vyper는 이를 방지하기 위해 다음과 같은 제한을 둔다.

| 기능          | Solidity                        | Vyper                                         |
| ------------- | ------------------------------- | --------------------------------------------- |
| `while` 문    | ✅ 사용 가능                    | ❌ 사용 불가                                  |
| `for` 문      | ✅ 사용 가능 (무제한 반복 가능) | ✅ 사용 가능하지만, **반복 횟수를 정해야 함** |
| **재귀 호출** | ✅ 사용 가능                    | ❌ 사용 불가                                  |

**📌 이유:**

무한 루프를 허용하면 가스 소모량을 예측할 수 없고, "Gas Limit Attack" 같은 공격에 취약해지기 때문.

---

## 5️⃣ **Vyper의 명확한 상태 변경 방식**

Solidity는 **선언된 변수나 상태가 언제 바뀌는지 명확하지 않아서** 예측이 어려울 수 있다. Vyper는 이를 방지하기 위해 **"Condition → Effects → Interaction"** 순서를 따를 것을 권장한다.

✅ **Vyper에서 코드 작성 시 고려할 점**

1. **Condition (조건 확인)** → 함수 실행 전에 필요한 상태를 확인해야 함
2. **Effects (상태 변경)** → 필요한 상태 변경을 수행해야 함
3. **Interaction (외부 컨트랙트와 상호작용)** → 마지막에 실행해야 함

💡 **예제 코드:**

```python
@public
def withdraw(amount: uint256):
    assert self.balance >= amount  # Condition
    self.balance -= amount         # Effects
    send(msg.sender, amount)       # Interaction
```

🚨 **반대로 Interaction을 먼저 하면, 재진입 공격(Reentrancy Attack)에 취약해질 수 있음!**

## 6️⃣ **Vyper의 함수 데코레이터 (Decorators)**

Vyper에서는 함수의 역할을 명확히 하기 위해 **데코레이터(@)를 사용**한다.

| 데코레이터  | 설명                       | 예제                                          |
| ----------- | -------------------------- | --------------------------------------------- |
| `@public`   | 공개 함수 (외부 호출 가능) | `@public def deposit(): ...`                  |
| `@private`  | 내부 함수 (외부 호출 불가) | `@private def _internal_logic(): ...`         |
| `@constant` | 상태를 변경할 수 없는 함수 | `@constant def get_balance() -> uint256: ...` |
| `@payable`  | 이더를 받을 수 있는 함수   | `@payable def receive_funds(): ...`           |

🚨 `@constant`와 `@payable`을 같이 쓰면 오류 발생 → **돈을 보내는 함수는 상태 변경이 필수적이기 때문!**

---

## 7️⃣ **Vyper의 보안 기능**

### 📌 **🛡️ Overflow 방지**

Solidity에서는 `SafeMath` 라이브러리를 사용해야 오버플로우(Overflow)를 방지할 수 있지만, **Vyper는 기본적으로 모든 연산에 대해 자동으로 오버플로우 방지를 적용**한다.

💡 Solidity 코드 (취약한 코드)

```solidity
uint256 a = 2**256 - 1;
a = a + 1;  // Overflow 발생 → 0이 됨
```

🔥 **Vyper에서는 자동으로 예외(Exception) 발생 → 안전한 코드 실행!**

## 8️⃣ **Vyper의 데이터 저장 방식**

| 저장 위치        | 설명                                        | 활용 예제                          |
| ---------------- | ------------------------------------------- | ---------------------------------- |
| **Global State** | 스마트 컨트랙트의 저장 공간 (비싸고 영구적) | `self.balance = 100`               |
| **Logs**         | 블록체인에 기록되지만 읽을 수 없음          | `log.Transfer(msg.sender, amount)` |

📌 **로그(Log)는 컨트랙트 내부에서는 읽을 수 없고, Etherscan 같은 외부 서비스에서만 확인 가능!**

<summary>Log VS. Function</summary>
- **이벤트(****`event`****)와 함수 실행의 차이**

|                        | **함수 실행 (\*\***`function`\***\*)** | **이벤트 로그 (\*\***`event log`\***\*)**    |
| ---------------------- | -------------------------------------- | -------------------------------------------- |
| 실행 방식              | 컨트랙트 내부에서 실행                 | 블록체인에 "기록"만 남김                     |
| 데이터 저장            | 컨트랙트의 상태 (`Global State`) 변경  | 블록체인 로그에 저장됨                       |
| 비용(가스)             | 비싸다 (Global State 변경 포함)        | 상대적으로 저렴 (저장공간 필요 없음)         |
| 컨트랙트 내부에서 읽기 | ✅ 가능 (함수 내에서 상태 변수 사용)   | ❌ 불가능 (로그는 블록체인에만 존재)         |
| 활용 사례              | 상태 변경이 필요한 로직                | 기록이 필요하지만 상태 변경이 필요 없는 경우 |

### **📌 핵심 정리**

- **이벤트 로그(\*\***`event`\***\*)는 실행(X), 기록(O)**
- **컨트랙트 내부 상태 변화 없음** → 단순히 "무엇이 발생했다"는 흔적만 남김
- **블록체인에 기록되지만, 컨트랙트 내부에서는 다시 읽을 수 없음**
- **외부에서 확인(Web3.js, Etherscan, The Graph 등)이 가능**

---

### **📌 ✅ 비유: "공식 인증 도장 찍기"**

👉 **컨트랙트 내부에서** **`event`\*\***를 호출하는 것은 마치 공문서에 도장을 찍는 것과 같음.\*\*

- 도장을 찍는다고 해서 문서 내용이 바뀌는 것은 아님.
- 하지만, 누가 봐도 이 문서가 공식적으로 "발행"되었음을 알 수 있음.
- 문서를 다시 수정하려면 따로 저장을 해야 하지만, 도장 자체는 그 역할을 하지 않음.
- 도장을 보고 "이게 진짜 문서구나!" 하고 확인할 수 있지만, 문서를 작성하는 데 영향을 주진 않음.

➡️ **이벤트 로그도 마찬가지로 "트랜잭션이 실제로 발생했다"는 것을 남기는 용도!**

## **※ Vyper의 온라인 코드 에디터 & 컴파일러**

Vyper는 온라인 코드 에디터와 컴파일러가 있음

- 스마트컨트랙트 ⇒ 바이트코드, ABI, LLL 로 웹브라우저에서 변환해줌
- 오직 한가지 버전의 컴파일러 소프트웨어를 제공하고 정기적으로 업데이트 됨
- Etherscan 은 온라인 Vyper 컴파일러가 컴파일러 버전을 선택할 수 있게 지원함
  - Remix 도 Vyper 플러그인을 환경설정 탭에서 지원함

---

## 🔥 **결론: Vyper의 특징 요약**

✅ **Solidity보다 보안성이 높고, 실수를 방지하도록 설계됨**

✅ **읽기 쉽고 감사(Audit)하기 좋은 구조**

✅ **불필요한 기능(Modifiers, Inheritance 등)을 제거하여 간결한 코드 유지**

✅ **무한 루프, 오버플로우 등의 보안 문제를 원천 차단**
