## 📌 **1. 트랜잭션(Transaction)이란?**

- 이더리움은 하나의 거대한 **상태 기계(State Machine)**.
- 트랜잭션은 **상태를 변화시키는 유일한 방법**이며, EVM에서 스마트 컨트랙트를 실행시키는 유일한 수단.
- \*외부 계정(EOA)\*\*만이 트랜잭션을 생성할 수 있으며, 스마트 컨트랙트는 직접 트랜잭션을 생성하지 못함.
- 스마트 컨트랙트는 다른 트랜잭션에 의해 호출될 때만 작동.
  > 📍 핵심 요약
  >
  > - **EOA** → **트랜잭션** 생성
  > - **트랜잭션** → **상태(State)** 변화
  > - **상태 변화** → **계약 실행**

---

## 📌 **2. 트랜잭션 구조(Transaction Structure)**

이더리움에서 트랜잭션은 다음의 필드를 가진 바이너리 메시지:

| 필드          | 설명                                               |
| ------------- | -------------------------------------------------- |
| **Nonce**     | 각 주소에서 보낸 트랜잭션의 순서                   |
| **Gas Price** | 가스 단위당 지불하고자 하는 Ether 가격 (단위: wei) |
| **Gas Limit** | 최대 지불 가능한 가스의 양                         |
| **Recipient** | 받는 사람의 주소 (EOA 또는 컨트랙트 주소)          |
| **Value**     | 보내는 Ether 금액                                  |
| **Data**      | 컨트랙트 호출 시 사용하는 추가 데이터              |
| **v, r, s**   | 디지털 서명을 위한 ECDSA 값 (송신자 증명)          |

- 이 데이터는 **RLP 인코딩**으로 직렬화됨.
- **From 주소**가 포함되지 않는데, 이는 **v, r, s 값을 통해 공개키를 복원하여 알 수 있기 때문**.

<summary>RLP 인코딩 원리 및 예시</summary>

### 📌 **1. RLP (Recursive Length Prefix) 인코딩**

RLP 인코딩은 **이더리움에서 데이터를 효율적으로 저장하고 전송하기 위한 직렬화 방식**이다. 특히 트랜잭션 데이터를 **최소한의 공간**을 차지하도록 압축하는 것이 목적이다.

### ✅ **RLP 인코딩 원리**

RLP는 **두 가지 주요 요소**로 이루어진다.

1. **데이터가 단순한 단일 값** (바이트 스트링)
2. **데이터가 여러 개의 값으로 이루어진 리스트** (배열)

각각의 경우 RLP 인코딩 방식이 다르다.

### ✅ **RLP 인코딩 방식 (단계별)**

**단일 값(Value)의 경우**

1. **0~127 범위(1바이트) 숫자**
   → 그대로 저장 (예: `0x7F` → `0x7F`)
2. **0~55 바이트 데이터**
   → `0x80 + 데이터 길이` + `데이터` (예: `"dog"` → `0x83 646F67`)
3. **56바이트 이상 데이터**
   → `0xB7 + 데이터 길이(바이트)` + `데이터`

**리스트(List)의 경우**

1. **전체 데이터가 55바이트 이하**
   → `0xC0 + 리스트 길이` + `RLP(각 요소)`
2. **전체 데이터가 56바이트 이상**
   → `0xF7 + 리스트 길이(바이트)` + `RLP(각 요소)`

---

### ✅ **RLP 인코딩 예제**

**예제 1: 문자열 "dog" (단일 값)**

1. "dog" → 바이트 변환 → `0x646F67`
2. 길이 = 3바이트 → `0x80 + 3 = 0x83`
3. 최종 결과 = `0x83 646F67`

**예제 2: 리스트 ["cat", "dog"]**

1. "cat" → `0x83636174` (RLP 변환)
2. "dog" → `0x83646F67` (RLP 변환)
3. 리스트 길이 = `0x83636174` + `0x83646F67` = 6바이트
   → `0xC0 + 6 = 0xC6`
4. 최종 결과: `0xC6 83636174 83646F67`

---

## 📌 **3. 논스(Nonce)의 중요성**

- 논스는 **트랜잭션의 순서**를 나타내고, **중복 트랜잭션 방지**에 사용됨.
- 각 계정은 독립된 논스 값을 가짐 (0부터 시작해서 1씩 증가).

### 🚩 **논스의 필요성 예시**

- 트랜잭션 순서 유지

  ① **논스 3:** 6 Ether 전송 (중요 거래, 잔액 충분)

  ② **논스 4:** 8 Ether 전송 (잔액 부족으로 실패)

  ⇒ **논스 덕분에** 논스3이 우선 실행되고, 논스4는 실패하여 트랜잭션 순서 유지 가능.

- 재전송 공격 방지 (중복 방지)

  동일한 거래를 여러 번 복사해서 다시 전송해도, 논스가 다르므로 중복 거래를 막을 수 있음.

### 🚩 **논스 주의사항**

- 트랜잭션 논스에 빈칸(누락)이 있으면, 이후 트랜잭션은 처리되지 않고 멈춤.
- 같은 논스가 중복되면 하나만 채택됨.

---

## 📌 **4. 가스(Gas)의 역할**

- 이더리움의 트랜잭션 처리 비용 측정 단위.
- 거래 시 가스 비용은 다음과 같이 계산됨:**Gas Cost = Gas Price × Gas Used**
- 트랜잭션이 가스 한도를 초과하면 트랜잭션이 실패하고 상태가 원상복구됨.

### 🚗 **자동차 비유로 이해하기**

- **Gas Limit:** 차량의 연료탱크 용량 (최대 사용 가능한 연료).
- **Gas Price:** 연료의 리터당 가격.
- **Gas Used:** 실제로 주행한 거리에 따른 연료 소비량.

## 📌 5**. Value와 Data 필드**

| 트랜잭션 유형           | Value | Data | 설명                             |
| ----------------------- | ----- | ---- | -------------------------------- |
| 지불만                  | ✅    | ❌   | Ether만 전송                     |
| 컨트랙트 함수 호출만    | ❌    | ✅   | 데이터로 컨트랙트 호출           |
| 지불 및 함수 호출       | ✅    | ✅   | Ether와 함께 컨트랙트 호출       |
| 지불도 호출도 아닌 경우 | ❌    | ❌   | (가스만 낭비하는 의미 없는 거래) |

---

## 📌 6**. 디지털 서명(ECDSA)**

- 트랜잭션은 ECDSA 알고리즘으로 서명됨.
- 서명 과정:
  ① 트랜잭션 데이터 → RLP 인코딩

      ② Keccak-256 해시 계산


      ③ 서명자의 개인 키로 ECDSA 서명


      ④ 생성된 서명값 (v, r, s)을 트랜잭션에 추가

- 서명을 통해:

  🔹 소유권 증명

  🔹 거래 부인 방지

  🔹 거래 데이터 무결성 보장

<summary>**Raw Transaction Creation with EIP-155**</summary>

### **📌 EIP-155란?**

EIP-155는 **리플레이 공격(Replay Attack) 방지**를 위한 이더리움 개선 제안(Ethereum Improvement Proposal)으로, 2016년에 도입됨.

### **💡 리플레이 공격이 뭔데?**

이전에는 이더리움(ETH)과 이더리움 클래식(ETC)이 같은 체인을 공유하고 있어서, **한쪽 체인에서 보낸 트랜잭션이 다른 체인에서도 유효하게 실행될 수 있는 문제**가 있었어.

예를 들어:

1. A가 B에게 10 ETH를 전송하는 트랜잭션을 Ethereum 메인넷에서 전송 💰
2. B가 이 트랜잭션을 복사해서 Ethereum Classic 네트워크에서도 전송 🤯
3. A는 의도하지 않았지만 B에게 10 ETC도 보냄 😱 (같은 프라이빗 키를 가진 계정이므로)

👉 이 문제를 해결하기 위해 **EIP-155는 트랜잭션에 "체인 ID"를 포함하도록 변경**했어.

👉 각 블록체인마다 고유한 **체인 ID**를 부여해서, 한 네트워크에서 서명한 트랜잭션이 다른 네트워크에서 무효하도록 만듦!

<summary>EIP-55(이더리움 주소 체크섬, EIP-155랑 다름)</summary>

## **✅ EIP-155 vs EIP-55 차이점**

| EIP         | 개념                        | 역할                                                       | 도입 목적                                                                                                                                     | 예제                                                                  |
| ----------- | --------------------------- | ---------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| **EIP-155** | **트랜잭션 리플레이 방지**  | 네트워크마다 트랜잭션을 구별하기 위해 **체인 ID를 추가**   | **Ethereum과 Ethereum Classic 같은 체인이 분리된 후, 서로 다른 체인에서 트랜잭션이 중복 실행되는 문제(리플레이 공격)를 방지하기 위해 도입됨** | _체인 ID:_ _`1`_ _(Ethereum),_ _`61`_ _(Ethereum Classic) 등_         |
| **EIP-55**  | **주소 체크섬 (오타 방지)** | Ethereum 주소의 **대소문자 체크섬**을 추가하여 오타를 감지 | **잘못된 Ethereum 주소 입력을 방지하여, 사용자가 실수로 잘못된 주소로 자금을 보내는 문제를 방지**                                             | _`0x52908400098527886E0F7030069857D2E4169EE7`_ _(EIP-55 적용된 주소)_ |

### 📌 **EIP-55란?**

**EIP-55**는 **Ethereum 주소의 오류 검출을 위한 대소문자 체크섬(Address Checksums)** 방식이야.

Ethereum의 주소는 **40자리 16진수(0**~~**9, A**~~**F)로 구성된 20바이트(160비트) 길이**를 가지는데,

이게 전부 **소문자**나 **대문자**로만 표시될 수도 있어.

✔️ **EIP-55 이전 문제**

- Ethereum의 주소는 대소문자를 구분하지 않아도 유효했음 (즉, `0xabcd...`와 `0xABCD...`는 동일한 주소)
- 하지만 오타가 발생하면, 잘못된 주소로 돈이 보내질 수 있음! 😨

✔️ **EIP-55 이후 해결책**

- **주소의 특정 글자를 대문자로 변환하는 체크섬 방식**을 적용하여 오타를 감지할 수 있도록 변경
- 사용자가 **잘못된 주소를 입력하면, 지갑 소프트웨어에서 오류를 감지**할 수 있음.

---

## **📍 EIP-55 도입 배경 (왜 필요한가?)**

Ethereum의 주소 체계는 Bitcoin과 다르게 **체크섬을 포함하지 않은 순수한 16진수(hex) 포맷**이었음.

즉, **Ethereum의 주소는 원래 오타 감지 기능이 없었음**.

예를 들어:

Bitcoin 주소: `1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa` (체크섬 포함)

Ethereum 주소: `0x4bbeeb066ed09b7aed07bf39eee0460dfa261520` (체크섬 없음)

💡 **문제점**

✔️ 사용자가 **한 글자라도 잘못 입력하면**, 완전히 다른 주소로 전송될 가능성이 있음.

✔️ 대부분의 Ethereum 지갑은 **QR 코드**나 **주소 복사-붙여넣기**를 이용하지만,

✔️ **수기로 입력하는 경우** 오타가 발생할 위험이 있음.

✔️ Ethereum 네트워크에는 **"잘못 보낸 트랜잭션을 되돌릴 방법이 없음!"** 😨

💡 **해결책**

✔️ Ethereum 주소를 **Keccak-256 해싱하여 체크섬을 적용하는 방식**을 도입

✔️ 이더리움 주소를 **대소문자 섞인 형태**로 변환하여 **오타 감지 가능**하도록 함.

✔️ 지갑이나 블록 탐색기에서 **체크섬이 적용되지 않은 주소 입력 시 경고**를 띄움.

---

## **📍 EIP-55 체크섬 적용 방식 (어떻게 동작하는가?)**

### **🚀 1️⃣ 기본 원리**

1. Ethereum 주소의 **16진수 표현**을 모두 **소문자로 변환** (`0x` 제외)
2. **Keccak-256 해시**를 생성 (Keccak은 Ethereum에서 사용하는 SHA3 해시 알고리즘)
3. 생성된 해시 값을 이용하여 주소 문자열에서 **일부 문자만 대문자로 변환**
   - Keccak 해시값의 각 바이트를 보고, 7보다 크면 해당 문자를 대문자로 변경
4. 최종적으로 **대소문자가 섞인 체크섬 주소**가 생성됨.

---

### **🚀 2️⃣ 체크섬 변환 예제 (Step by Step)**

예제 주소:

```bash
0x52908400098527886E0F7030069857D2E4169EE7
```

### **✅ Step 1: 소문자로 변환**

```bash
0x52908400098527886e0f7030069857d2e4169ee7
```

### **✅ Step 2: Keccak-256 해시 생성**

해시 결과:

```bash
0x1c1d9c3f78f6a23e902b101f81eb4ac69b8c5e1d3d1b6783f373c3a68818c1b1
```

### **✅ Step 3: 특정 문자 대문자로 변경**

- Keccak 해시의 첫 번째 바이트: `1C` (16진수로 1C = 28)
  → 28 (10진수) → **첫 번째 문자는 그대로 소문자 유지**
- 두 번째 바이트: `1D` (16진수로 1D = 29)
  → 29 (10진수) → **두 번째 문자는 대문자로 변경**

결과적으로 최종 체크섬 적용 주소:

```bash
0x52908400098527886E0F7030069857D2E4169EE7
```

✅ 대소문자가 섞여 있음!

---

## **📍 EIP-55 체크섬이 적용되지 않은 주소와 비교**

| 주소 타입            | 예제 주소                                    |
| -------------------- | -------------------------------------------- |
| 일반 주소 (소문자)   | `0x52908400098527886e0f7030069857d2e4169ee7` |
| 체크섬 주소 (EIP-55) | `0x52908400098527886E0F7030069857D2E4169EE7` |

💡 **차이점**
✔️ **EIP-55 체크섬 주소는 특정 글자가 대문자로 표시됨**

✔️ **소문자로만 된 주소는 오타 감지 불가**

✔️ **체크섬 주소를 사용하면 오타를 감지할 수 있음** (잘못 입력하면 오류 발생)

---

## **📍 EIP-55 적용 방식**

### **🚀 1️⃣ 지갑과 블록 탐색기에서 체크섬 적용**

- Metamask, MyEtherWallet(MEW), Etherscan 같은 **지갑 및 블록 탐색기**는 **EIP-55 체크섬을 적용한 주소만 유효한 것으로 간주**
- 사용자가 **잘못된 대소문자를 입력하면 오류 메시지 출력!** 🚨

### **🚀 2️⃣ 스마트 계약에서 체크섬 검증 가능**

- Solidity에서 `keccak256`을 이용해 체크섬이 올바른지 검증 가능:

```solidity
function validateAddress(string memory _input) public pure returns (bool) {
    return keccak256(abi.encodePacked(_input))
    == keccak256(abi.encodePacked("0x52908400098527886E0F7030069857D2E4169EE7"));
   }
```

✔️ 이더리움 스마트 컨트랙트에서도 주소의 유효성을 체크할 수 있음!

---

## **📍 체크섬이 적용되지 않은 주소를 입력하면 어떻게 될까?**

**EIP-55가 적용된 시스템에서, 체크섬이 없는 주소를 입력하면 오류 발생!**

예를 들어:

1. Metamask에서 **잘못된 대소문자 주소 입력**
2. Metamask는 **Keccak-256 해시를 확인**하고 올바른지 체크
3. **오류 메시지 출력!** → "주소가 유효하지 않습니다."

---

## **📍 EIP-55의 한계점**

✔️ EIP-55는 **오타를 감지할 수는 있지만, 오타를 교정해 주지는 않음**

✔️ **체크섬이 있는 주소만 인식하는 소프트웨어에서는 체크섬 없는 주소가 오류로 인식될 수 있음**

✔️ QR 코드 스캔이나 복사-붙여넣기를 주로 사용하면 여전히 **체크섬 기능이 크게 필요하지 않을 수도 있음**

---

## **🚀 정리**

### **🔹 EIP-55의 핵심 내용**

✅ **Ethereum 주소의 오타 감지 기능 추가**

✅ **Keccak-256 해싱을 이용하여 특정 문자를 대문자로 변환**

✅ **대소문자가 섞인 주소를 사용하면 오타 방지 가능**

✅ **지갑 및 블록 탐색기에서 체크섬 적용 주소만 허용 가능**

---

### **🔹 EIP-55 적용 시 효과**

✔️ **수동 입력 시 오타 발생 방지**

✔️ **잘못된 주소 입력 시, 지갑이 자동으로 오류 감지**

✔️ **리플레이 공격과 같은 보안 문제는 해결하지 않지만, 트랜잭션을 보낼 때의 실수를 방지**

---

📌 **EIP-55는 트랜잭션을 보호하는 것이 아니라, "주소 입력 실수"를 줄이는 역할을 한다!**

📌 **Ethereum 생태계에서 지갑과 블록 탐색기들은 대부분 EIP-55 체크섬을 적용하고 있다!** ✅

---

### **📌 EIP-155를 적용한 Raw Transaction 생성 과정**

이제 EIP-155 방식으로 트랜잭션을 어떻게 생성하는지 단계적으로 보자.

### **📍 Step 1: 트랜잭션 데이터 구성**

EIP-155를 적용하면, 기존 트랜잭션 구조에 **"chainId", "0", "0"** 이 추가됨.

기존 구조:

```json
{
  "nonce": 0,
  "gasPrice": "0x09184e72a000", // 10 Gwei
  "gasLimit": "0x30000", // 200,000 Gas
  "to": "0xrecipient_address",
  "value": "0x01", // 1 wei
  "data": "" // 일반 ETH 전송이므로 없음
}
```

🚨 **EIP-155 적용 후**

```json
{
  "nonce": 0,
  "gasPrice": "0x09184e72a000",
  "gasLimit": "0x30000",
  "to": "0xrecipient_address",
  "value": "0x01",
  "data": "",
  "chainId": 1, // Ethereum 메인넷 체인 ID
  "0": 0,
  "0": 0
}
```

✔️ **체인 ID 추가**

✔️ **"0", "0" 필드 추가**

---

### **📍 Step 2: 트랜잭션 서명**

트랜잭션 데이터를 **RLP-인코딩(RLP-Encoding)**한 후, Keccak-256 해시를 적용한 값을 서명해야 해.

👉 **서명 방식**

1. 위에서 만든 트랜잭션을 RLP 인코딩
2. Keccak-256 해싱 적용
3. **ECDSA 서명**을 사용하여 v, r, s 서명 생성
   - v 값이 **"chainId \* 2 + 35 or 36"** 형태로 변경됨 (EIP-155 적용)
   - 예) `v = (1 * 2) + 35 = 37`

---

### **📍 Step 3: 서명된 트랜잭션 전송**

서명이 완료된 트랜잭션을 Ethereum 네트워크에 전송!

```bash
const Web3 = require("web3");
const EthereumTx = require("ethereumjs-tx").Transaction;

const web3 = new Web3("https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID");

const rawTx = {
nonce: web3.utils.toHex(0),
gasPrice: web3.utils.toHex(web3.utils.toWei("10", "gwei")),
gasLimit: web3.utils.toHex(21000),
to: "0xRecipientAddress",
value: web3.utils.toHex(web3.utils.toWei("0.1", "ether")),
chainId: 1 // EIP-155 적용};

const privateKey = Buffer.from("YOUR_PRIVATE_KEY", "hex");
const tx = new EthereumTx(rawTx, { chain: "mainnet" });
tx.sign(privateKey);

const serializedTx = tx.serialize();
web3.eth.sendSignedTransaction("0x" + serializedTx.toString("hex"))
.on("receipt", console.log);

```

✔️ **EIP-155 적용됨**

✔️ **체인 ID 포함 → 리플레이 공격 방지**

✔️ **서명 후 전송**

---

### **📌 🚀 쉽게 이해하는 비유**

🔗 **EIP-155 전**

➡️ "서울에서 보낸 택배가 부산에서도 그대로 유효한 상황" (다른 체인에서도 실행됨)

🔗 **EIP-155 후**

➡️ "택배에 `대한민국`이라는 태그를 붙여서, 미국에서는 유효하지 않도록 만듦!" (네트워크 간 구분)

---

## 📌 7**. 오프라인 서명 (Offline Signing)**

- 트랜잭션 생성과 서명을 분리하는 방식.
- 개인 키 노출 위험 최소화 위해 사용됨.

| 단계 | 설명                                   |
| ---- | -------------------------------------- |
| ①    | 온라인 컴퓨터에서 미서명 트랜잭션 생성 |
| ②    | 오프라인 컴퓨터로 전달 후 서명         |
| ③    | 서명된 트랜잭션 다시 온라인으로 전달   |
| ④    | 서명된 트랜잭션을 네트워크에 전송      |

## 📌 8**. 멀티시그(Multi-Signature)**

- 여러 서명이 필요한 트랜잭션 방식.
- **컨트랙트**로 구현 가능.
- 예시: 3명의 서명자 중 2명이 서명해야 Ether를 이동 가능(2-of-3).
